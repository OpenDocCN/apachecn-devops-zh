# 管理工作流

在本章中，我们将把前几章中描述的不同流程整合到一个通用工作流中，这样我们就可以对单个微服务进行更改。我们将从获取新功能请求的过程继续到本地开发、审查、在演示环境中测试，以及批准更改并将其发布到实时集群。

这与我们在[第 4 章](04.html)、*创建管道和工作流*中介绍的管道概念有关。然而，在本章中，我们将讨论任务的过程。管道和建筑结构在那里，以确保任何提议的变更符合质量标准。在这一章中，我们将重点关注该技术的团队合作方面，以及如何在跟踪不同变化的同时实现流畅的交互。

在本章中，我们将涵盖以下主题:

*   了解功能的生命周期
*   审查和批准新功能
*   设置多个环境
*   扩展工作流程并使其发挥作用

到本章结束时，我们将清楚地看到为我们的一个微服务设置新功能所涉及的不同步骤，以及我们如何使用多个环境来测试并确保发布成功。

# 了解功能的生命周期

遵循敏捷原则，任何团队的主要目标都是能够快速实现新特性，而不会影响系统的质量或稳定性。变化的第一个要素是**特征请求**的形状。

A feature request is a description of a change in the system in non-technical terms. Feature requests are normally generated by non-engineers (product owners, managers, and CEOs) who are looking to improve the system for business-related reasons, such as making a better product or increasing revenue.

Feature requests can be simple, such as *updating the logo of the company in the main page*, or big and complicated, such as *adding support to the new 5G network*. Feature requests may include bug reports. While they don't usually, they will for the purpose of this chapter.

复杂的特性请求可能需要被细分成更小的独立的特性请求，这样我们就可以以小的增量迭代。

Our focus is on the elements that need to be taken into account due to the microservices approaches and practices more than agile practices. Such practices deal with how to structure feature requests into tasks and estimations, but they are not specific to the underlying technologies.

Take a look at the *Further reading* section at the end of this chapter to find out more about agile practices and methodologies.

在一个整体中，所有的元素都在同一个代码基础下。因此，无论特定功能请求有多复杂，都只会影响一个系统。整体中只有一个单一的系统。然而，一旦我们迁移到微服务，情况就不是这样了。

在微服务架构中，我们需要分析任何传入的特性请求，看它影响什么微服务。如果我们正确设计我们的微服务，大多数请求将只影响单个微服务。然而，最终，一些功能请求会太大，无法整齐地放入单个微服务中，并且需要分成两个或更多步骤，每个步骤改变一个不同的微服务。

例如，如果我们有一个新的功能请求，允许我们在一个想法的文本中提到一个用户(类似于一个提及在推特上是如何工作的)，那么这个提及将必须存储在想法后端，并显示在前端。这个特性影响两个微服务:前端和思想后端。

In this section, we are referring to concepts that we introduced in the previous chapters and are joining them together from a global point of view.

在下一小节中，我们将研究影响多个微服务的特性。

# 影响多个微服务的功能

对于多微服务功能请求，您需要将该功能分成几个技术功能，每个功能影响一个微服务。

每个技术特性都应该涵盖与其影响的微服务相关的一个方面。如果每个微服务都有一个明确的目的和目标，那么这个特性将被完成和推广，以便它可以用于以后的请求。

The basis for a successful microservice architecture is to have loosely coupled services. Ensuring that the API of each microservice makes sense on its own is important if we wish to avoid blurring the lines between services. Not doing so may mean that independent work and deployments aren't allowed.

还应该考虑请求和微服务之间的依赖关系，以便工作可以前后安排。这意味着准备添加额外数据或功能的新特性，但默认情况下保留旧行为。这样做之后，可以部署一个使用这些额外数据的新特性。这种工作方式确保了在任何给定时间的向后兼容性。

We will look at the features that affect multiple microservices in more detail in [Chapter 11](11.html), *Handling Change, Dependencies, and Secrets in the System*. We'll also learn how to coordinate work and dependencies in more detail.

回到我们前面的例子，要在用户的想法中添加用户的提及，我们需要让想法后端能够处理对用户的可选引用。这是一个独立的任务，不会影响现有的功能。它可以被部署和测试。

然后，我们可以在 Frontend 中进行相应的更改，以允许外部用户通过一个 HTML 界面与其进行交互。

正如我们在[第 1 章](01.html)、*行动起来——设计、规划和执行*中所讨论的，对于任何微服务架构来说，我们能够独立部署服务是至关重要的。这使我们能够独立测试服务，并避免任何需要复杂部署的开销，如果出现错误，我们很难进行调试和回滚。

如果不同的团队在不同的微服务上独立工作，那么他们也需要协调。

在下一节中，我们将学习如何在单个微服务中实现一个特性。

# 实现功能

一旦我们有了独立技术特性的定义，它就可以实现了。

Defining a technical feature in a clear manner can be challenging. Remember that a single feature may need to be further subdivided into smaller tasks. However, as we mentioned previously, the objective here is not to structure our tasks. 

通过创建一个新的 Git 分支来开始您的任务。代码可以更改，以反映该分支中的新功能。正如我们在[第 2 章](02.html)、*用 Python 创建 REST 服务*和[第 3 章](03.html)、*使用 Docker* 构建、运行和测试您的服务时所看到的，可以运行单元测试来确保这项工作不会破坏构建。

As we described in [Chapter 3](03.html), *Build, Run, and Test Your Service Using Docker*, in the *Operating with an immutable container* section, we can use `pytest` arguments to run subsets of tests to speed up development, thereby enabling quick feedback when running tests. Make sure you use it. 

可以通过部署本地集群来检查该功能如何与整个系统相关地工作。这将启动可能受该分支中的工作影响的其他微服务，但它有助于确保当前工作不会中断任何影响其他微服务的现有调用。

基于这个管道，任何推送到 Git 的提交都将运行它的所有测试。这将及早发现问题，并确保在与主分支合并之前构建是正确的。

在这个过程中，我们可以使用拉请求来检查主分支和新特性之间的变化。我们可以在合并之前检查我们的 GitHub 配置，以确保代码状态良好。

一旦特性准备好并与主分支合并，就应该创建一个新的标签来允许它的部署。作为已配置管道的一部分，此标记将触发一个构建，该构建在注册表中生成一个映像，并用相同的标记标记该映像。标签和映像是不可变的，所以我们可以确定代码不会在不同的环境中改变。您可以放心地向前和向后滚动，代码将与标签中定义的代码完全相同。

正如我们在[第 8 章](08.html)*中看到的，使用 GitOps 原则*，可以通过遵循 GitOps 原则来部署标签。部署在 Git 控制下的 Kubernetes 配置文件中进行描述，并在需要批准的请求中进行审查。一旦拉取请求与主分支合并，它将由 Flux 自动部署，如我们在[第 8 章](08.html)、*中使用 GitOps 原则*所述，在*中设置 Flux 来控制 Kubernetes 集群*部分。此时，该功能在集群中可用。

让我们回顾一下这个生命周期，从技术请求的描述到何时部署到集群:

This is a more complete version of the Flow that we introduced in [Chapter 4](04.html), *Creating a Pipeline and Workflow*.

1.  技术请求已准备好实施到单个微服务中。
2.  将创建一个新的特征分支。
3.  微服务的代码在这个分支中被改变，直到特性准备好。
4.  创建用于将特征分支合并到主分支的拉请求。如[第 4 章](04.html)、*创建管道和工作流*中所述，在*理解持续集成实践*部分，运行 CI 流程以确保其高质量。
5.  拉取请求被审查、批准并合并到主分支中。
6.  将创建一个新标签。
7.  在 GitOps 存储库中创建一个部署分支，将微服务的版本更改为新的标签。
8.  将创建一个用于合并此部署分支的请求。然后，它被审查和合并。
9.  一旦代码被合并，集群会自动发布微服务的新版本。
10.  最后，集群中提供了新功能！

This is a simplified version of the life cycle; in reality, it may be more complicated. Later in this chapter, we will look at a situation where the life cycle needs to be deployed to more than one cluster.

在下一节中，我们将了解一些关于审查和批准请求的建议。

# 审查和批准新功能

正如我们在[第 4 章](04.html)、*创建管道和工作流*中描述的管道模型所指定的，候选代码经过一系列阶段，如果有问题就停止。

正如我们前面提到的，如果我们希望在微服务的代码中引入新的特性，并且希望通过 GitOps 实践将这些变化部署到集群中，那么使用 GitHub pull 请求进行审查是可行的。

在这两种情况下，我们都可以通过自动化测试和流程自动检查这一点。然而，还有最后一步需要人工干预:知识传授和多一双眼睛。一旦审阅者认为新功能已经准备好，他们就可以批准它。

这些工具是相同的，尽管审查过程的工作方式略有不同。这是因为目标不一样。对于功能代码，在它被批准并合并到主分支之前，评审更容易被讨论。另一方面，审查和批准一个版本通常更直接、更快。

让我们从学习如何检查功能代码开始。

# 查看功能代码

代码审查可以在功能开发期间启动，并且已经打开了合并它的请求。正如我们已经看到的，在 GitHub 中，代码可以在**拉取请求**阶段被检查。

代码评审基本上是关于代码和新特性的成型讨论；也就是说，在将代码引入主分支之前，我们正在检查代码。这为我们提供了在功能开发过程中以及成为系统组件之前对其进行改进的机会。

在这里，团队的一个成员可能会阅读尚未合并的代码，并给作者一些反馈。这可以反复进行，直到审阅者认为代码可以合并并批准它。本质上，除了该特性的作者之外，其他人需要同意新代码符合要求的标准。

Code bases grow over time and their components can help each other out. Merging code into the main branch states that you fully accept that the new code will be maintained by the team as part of the code base.

代码可能需要由一个或多个人员或特定人员批准。

In GitHub, you can enable code owners. These are engineers who are responsible for approving repositories, or parts of repositories. Check out the GitHub documentation for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).

如今，代码审查是一个非常常见的过程，在 GitHub 中使用拉请求的流行性和易用性已经传播开来。大多数开发人员都熟悉这个过程。

然而，实现一个好的反馈文化比看起来更难。写代码是一种深刻的个人体验；没有两个人会写同样的代码。对于开发人员来说，除非有明确的规则，否则让您的代码受到他人的批评可能是一种困难的体验。

以下是一些建议:

*   告诉你的审稿人他们应该寻找什么。一定要遵循清单。这有助于在团队中培养一种文化，使他们关心共同的核心价值观。这也有助于初级开发人员知道要寻找什么。这可能会因团队而异，但以下是一些示例:
    *   有新的测试。
    *   测试错误条件。
    *   文档已正确更新。
    *   任何新的端点都符合标准。
    *   架构图已更新。
*   检查代码和编写代码不是一回事。总会有不一致的地方(例如，这个变量名可以更改)，但是需要审查的是是否需要实施这样的更改。吹毛求疵会侵蚀团队成员之间的信任。

*   要审查的代码越大，就越难做。最好以小的增量工作，这与持续集成的原则配合得很好。
*   所有守则都应在平等的基础上进行审查。这包括高级开发人员的代码，应该鼓励初级开发人员留下诚实的反馈。这有助于代码所有权及其公平性的增长。
*   代码审查是一种对话。评论不一定意味着评论者的反馈必须在你没有首先质疑的情况下实施。它开启了一个关于改进代码的对话，做出澄清和推回完全没问题。有时，处理请求的正确方式，也就是更改代码的一部分，是留下一个注释，解释为什么以特定的方式这样做。
*   评论有助于传播关于代码库的知识。不过，这不是万灵药。代码评审往往会陷入隧道式视野，只关注小问题，如错别字和局部代码片段，而不关注更大的元素。这就是为什么以小增量实现特性很重要:帮助你周围的人消化变化。
*   留下赞赏的评论很重要。创造一种欣赏写得好的代码的文化。只突出不好的地方会让作者的复习过程很痛苦。
*   批评应该针对代码，而不是程序员。确保你的审查是文明的。在这一步中，我们希望确保代码的高质量；作为评论者，你不想让自己看起来高人一等。

Code reviews can be stressful for those who aren't used to them. Some companies are creating principles and ideas to make this process less painful. A good example can be found at [https://www.recurse.com/social-rules](https://www.recurse.com/social-rules). Don't be afraid to define and share your own principles.

*   重要的是，代码可以在任何时候都得到批准，即使团队中有人休假或生病。确保您将批准授予团队的多个成员，以便批准过程本身不会成为瓶颈。

当您开始生成代码评审时，确保团队领导将这些考虑事项牢记在心，并强调为什么所有代码都要评审。

It is worth emphasizing how code reviews are not a technological solution, but a people-related one. As such, they can suffer from people-related problems such as big egos, adversarial discussions, or non-productive debates.

The microservice architecture is fit for big systems that have multiple people working on them. Teamwork is crucial. Part of that is ensuring that the code doesn't belong to a single person, but to a whole team. Code reviews are a great tool to that end, but be sure to actively look for healthy ones.

Over time, a consensus will develop and a lot of code will be developed consistently. In a healthy team, the amount of time that's spent on reviews should reduce.

随着时间的推移，团队将定期执行代码评审，但是在开始时设置这些基础可能会很复杂。确保你有时间介绍他们。正如我们之前提到的，一旦特性准备好了，我们就需要批准它。批准新特性的代码并将其合并到主分支是特性审查的最后阶段，但它仍然需要发布。发布在代码控制之下，它们也需要被审查。

# 批准发布

使用 GitOps 原则允许我们启用相同的审查和批准方法，以便我们可以在 Kubernetes 基础架构中进行更改。正如我们之前提到的，基础设施是由 Kubernetes 中的 YAML 文件定义的，这一事实允许我们控制这些变化。

对 Kubernetes 集群所做的任何更改都可能会受到拉取请求和审查方法的影响。这使得批准集群的发布成为一个简单的过程。

这有助于最大限度地减少问题，因为团队中有更多的成员参与到变更中，他们对基础设施的了解也更好。这与允许团队控制他们自己的部署和基础设施的 DevOps 原则很好地配合。

然而，GitOps 中的基础设施变更往往比常规的代码审查更容易审查。总的来说，它们是以非常小的增量完成的，大多数变化都非常简单，以至于引发争论的可能性极小。

一般来说，尽量使任何基础设施的变化尽可能小。基础设施变更的风险更大，因为错误可能会导致其中重要的部分瘫痪。变化越小，风险就越小，诊断任何问题就越容易。

我们提出的关于代码评审的所有建议也有其作用。最重要的一点是包括一些参考基础设施关键部分的指导方针。

Some sections of the infrastructure may be under the GitHub code owner's protection. This makes it mandatory for certain engineers to approve changes to critical parts of the infrastructure. Take a look at the documentation for more information: [https://help.github.com/en/articles/about-code-owners](https://help.github.com/en/articles/about-code-owners).

由于基础设施被定义为存储在 GitHub 中的代码，这也使得复制基础设施变得容易，从而大大简化了多个环境的生成。

# 设置多个环境

在 Kubernetes 下创建、复制和删除名称空间的简单性大大减少了以前保留环境的多个副本来复制底层基础架构的负担。你可以利用这一点。

基于我们前面提到的 GitOps 原则，我们可以定义新的名称空间来生成新的集群。我们可以使用另一个分支(例如，使用生产集群的`master`分支和演示集群的`demo`分支)，或者复制包含集群定义的文件并更改名称空间。

You can use different physical Kubernetes clusters for different purposes. It's better to leave the production cluster as not being shared with any other environment to reduce risks. However, every other environment could live in the same cluster, which won't affect external customers.

一些特性请求足以证明开发团队知道该做什么，比如错误报告。然而，其他人在开发过程中可能需要更多的测试和交流，以确保他们满足需求。当我们检查一个新特性是否对预期的外部用户有用，或者可能是一个更具探索性的特性时，情况可能就是这样。在这种情况下，我们需要调用一个外部方，即特性的最终批准者:*涉众*。

A stakeholder is a term from project management that specifies a third party, that is, the final user of a product or a user who's impacted by it. Here, we use the term to specify someone who's interested in a feature but external to the team, so they can't define the feature requirements from within. A stakeholder can be, for example, a manager, a customer, the CEO of the company, or a user of an internal tool. 

任何不得不处理涉众模糊定义的请求的开发人员，比如*允许按名字搜索*，都不得不调整它:*不，不是按名字，而是按姓氏*。

Ensure that you define a proper end to these kinds of tasks. Stakeholder feedback can be endless if it's allowed to run without limits. Define what is and is not included in it, as well as any deadlines, beforehand.

为了运行测试并确保正在开发的特性朝着正确的方向发展，您可以创建一个或多个演示环境，在这些环境中，您将在工作合并到主分支之前部署正在进行的工作。这将有助于我们与利益相关者分享这项工作，这样他们就可以在功能完成之前给我们反馈，而我们不必在生产环境中发布它。

正如我们在前面几章中看到的，在 Kubernetes 中生成一个新环境很容易。我们需要创建一个新的命名空间，然后复制集群的生产定义，从而改变命名空间。这将创建环境的副本。

更改正在开发的微服务的特定版本将允许我们创建它的工作版本。较新的版本可以像往常一样部署在这个演示环境中。

This is a simplified version. You may need to make changes between the production environment and demo environments, such as the number of replicas, and database setup. In such cases, a *template environment* could be used as a reference so that it's ready to be copied.

其他环境，如登台，可以以类似的方式创建，目的是创建测试，确保已经部署到生产中的代码能够按预期工作。这些测试可以是自动的，但是如果我们想检查用户体验是否足够，它们也可以是手动的。

A staging environment is a setup that works as a replica that's as faithful as possible to the production environment, which means we can run tests to provide assurance that the deployment in production will work. Staging normally helps us verify that the deployment process will be correct, as well as any final tests.

Staging environments are typically very expensive to run. After all, they are a copy of a production environment. With Kubernetes, you can replicate the production environment easily and reduce the required physical infrastructure. You can even start and stop it when it is not in use to reduce costs.

您可以使用多个环境以类似的方式创建级联部署结构。这意味着标签需要部署到登台环境中，并在进入生产环境之前获得批准。

现在让我们从开发人员的角度来看看如何处理这种结构。

# 扩展工作流程并使其发挥作用

实现这种工作方式的一些挑战包括创建一种提供充分反馈循环的文化，以及在快速检查新代码的同时仔细检查它。等待评审是一种被阻止的状态，它阻止开发人员实现被评审的特性。

虽然这段等待时间可以用于其他目的，但无法进步会迅速降低生产率。要么开发人员将并行保留一些特性，这从上下文切换的角度来看是很有问题的，要么他们需要等待并滚动他们的拇指，直到审查完成。

The context switch is probably the most serious killer of productivity. One of the keys to keeping your team's productivity high is being able to start and finish a task. If the task is small enough, it will be finished quickly, so swapping between projects is easier. However, working on two or more tasks at the same time is a very bad practice.

If this happens often, try to divide your tasks into smaller chunks.

为了能够平衡彻底检查代码和减少阻塞时间，有一些元素需要记住。

# 审核和批准由整个团队完成

任何时候都需要有足够的评审员。如果只有开发人员有经验，评审可能最终只能由团队中最资深的人来完成，例如团队领导。虽然这个人在原则上可能是更好的评审员，但从长远来看，这种结构会损害团队，因为评审员不能做任何其他事情。如果审阅者由于任何原因(如生病或度假)不在，开发和发布阶段的进展也将受阻。

相反，让整个团队都能够审查他们同行的代码。即使一个资深的贡献者在教团队的其他成员如何回顾方面扮演了一个更加积极主动的角色，过一段时间后，大多数回顾不应该需要他们的帮助。

最初，虽然实现这个过程需要积极的指导，但这通常会由团队的高级成员来领导。审查代码是一种可训练的能力，目标是在一段时间后，每个人都能够运行审查并被允许批准拉取请求。

部署请求遵循相同的过程。最终，团队中的每个人，或者至少相当数量的成员，应该能够部署一个版本。不过，最初的主要评审者可能是不同的人。

审查一个版本的最佳人选很可能是关于如何配置 Kubernetes 基础设施的专家，而不是微服务代码的专家。

# 理解不是每个批准都是一样的

请记住，特性的不同阶段并不同等重要。代码评审的早期过程是关于确保代码是可读的，并且保持质量标准。在早期阶段，代码会有相对较多的注释，并且会有更多的讨论，因为需要调整更多的元素。

A big part of reviews is creating code that is *understandable enough* that other members of the team understand it. Although some people claim that code reviews make everyone aware of the changes that other members of the team are implementing, in my experience, reviewers are not that aware of specific features. 

A good review, however, will ensure that nothing cryptic is being introduced into the code base and that the core elements are respected (elements such as introducing tests, keeping documentation up to date, and keeping code readable). As we suggested previously in this chapter, try to create an explicit list of things to check. It will help you make the reviews and code more consistent.

新特性的部署阶段只需要我们检查微服务的版本是否改变，以及基础设施的其余部分是否完好无损。这些通常非常小；他们中的大多数人都反复检查没有错别字，并且要更改的微服务是正确的。

# 为发布定义清晰的路径

拥有一个简单明了的过程有助于每个相关人员清楚地了解一个特性是如何从开发到发布到生产环境的。例如，基于我们已经讨论过的想法，我们最终可能会得到一个类似于下图所示的部署路径:

![](img/22480f67-8ebb-41fe-8395-f832aa7b5909.png)

对于这些步骤中的每一步，我们都需要验证该步骤是否正确。正如我们在[第 4 章](04.html)、*创建管道和工作流*中看到的，自动测试确保任何合并到主分支中的东西都不会破坏现有的构建。这涵盖了直到**创建标签**步骤的前一个图表。

同样，也有一种方法可以在应用后验证部署是否成功。以下是关于这方面的一些想法:

*   手动测试，检查部署的微服务是否按预期工作
*   自动化测试，例如在[第 4 章](04.html)、*创建管道和工作流*中描述的测试
*   检查要部署的映像是否已使用 Kubernetes 工具或版本 API 正确部署

一旦一个部署阶段成功完成，下一个阶段就可以开始了。

在非生产环境中执行部署将中断生产的风险降至最低，因为这将确保部署过程是正确的。该过程需要足够快以允许快速部署，从而使它们尽可能小。

The full process from merging into the main branch until the new version is released into the production environment should take less than a few hours, but ideally less than that.

If more time is required, the process is probably too heavy.

小规模、频繁的部署将最大限度地降低破坏生产环境的风险。在某些特殊情况下，常规流程可能会很慢，应使用紧急程序。

# 紧急放行

让我们假设生产中有一个关键的 bug，需要尽快解决。对于这些特殊情况，事先定义一个应急流程是可以的。

这个紧急过程可能包括加快审核速度，甚至完全跳过审核。这可能包括跳过中间版本(例如不提前部署到演示环境)。确保明确定义何时需要该流程，并确保仅在紧急情况下使用。

If your regular deployment process is fast enough, then there's no need for an emergency process. This is an excellent reason to try to increase deployment times.

回滚是这种情况的一个很好的例子。恢复上一个版本中引入了关键错误的微服务的部署，只在生产中回滚并返回到上一个版本，而不影响其他任何东西，是一个合理的过程。

请注意，在这里，我们是如何在保证已回滚的版本之前已经部署的情况下降低进行快速更改的风险的。这是一个很好的例子，说明了紧急程序是如何工作和降低风险的。

在发现异常情况时，运用你的常识，并事先与你的团队讨论如何处理它们。我们将在[第 12 章](12.html)、*中讨论跨团队协作和沟通。*

# 频繁发布并添加功能标志

正如我们刚刚看到的，虽然回滚是可能的，但普遍的共识应该是每个新部署都向前推进。新版本的代码包含以前版本的代码，以及一些小的更改。按照 Git 的操作方式，我们在一个被推进的分支(主分支)上工作。

这意味着必须避免几个活跃的长寿命分支。这种模式被称为*基于主干的开发*，这是推荐的以持续集成为目标的工作方式。在基于主干的开发中，特征分支是短暂的，并且总是与主分支(或主干)合并，这在 Git 中通常被称为`master`。

Trunk-based development avoids issues when we have long-lived branches that diverge from the main one, thus making the integration of several components complicated. The basis for continuous integration is to be able to always have code that can be released in small increments. This model takes "trunk" as the reference for the releases.

在下图中，我们可以看到**特征 A** 是如何合并到**主**分支的，以及**特征 B** 是如何仍在进行的。任何发布将来自**主**分支:

![](img/2dab7dbb-586a-4dea-a959-14ba5beea981.png)

如果**特性 A** 引入了一个 bug，一个新的 bug 修复分支将从**主模块**分支出来，并将被合并回来。注意结构是如何继续前进的。

为了让这个系统工作，特性分支需要是短暂的——通常只有几天。这使得合并变得容易，并允许小的增量变化，这是持续集成的关键。

# 使用特征标志

有时候，有些特性，从设计上来说，需要一次完成大的/剧烈的改变，比如一个新的用户界面。持续集成提倡的那种缓慢添加小特性的快速迭代周期在这些频繁发布的情况下是行不通的。新界面需要一次性包含所有元素，否则看起来会很奇怪。

当您希望以小的增量方式继续工作时，您可以使用功能标志，同时将功能的激活延迟到它准备好之后。

功能标志是启用或禁用特定功能的配置元素。这允许您通过配置更改来更改微服务的行为，它充当开关。

In Kubernetes, we use the `deployment.yaml` file to describe the environment variables, as well as ConfigMaps. We will discuss ConfigMaps in [Chapter 11](11.html), *Handling Change, Dependencies, and Secrets in the System*.

配置与每个单独的环境相关联。这使得我们有可能在一个特定的环境中呈现一个特性，而不是在另一个环境中，同时代码库保持不变。

例如，一个新的接口可以在一个特性标志下慢慢开发和保护。有些环境，如演示环境，仍然可以是活动的，以便收集内部反馈，但这不会显示在生产环境中。

一旦新界面准备好，就可以进行小的修改；例如，我们可以更改配置参数来启用它。这在外部看起来可能是一个很大的变化，但是如果我们换回参数，它很容易被还原。

Feature flags are useful when we're dealing with externally accessible services. Internal services can add more features without any issue since they'll only be called by other microservices in the system.

Internal microservices are normally okay with adding new features. Here, backward compatibility is respected. Externally accessible features sometimes require us to replace a feature with another for reasons including interface changes or the deprecation of products.

一个相关的方法是将一个特性滚动到用户子集。这可以是一组预定义的用户，例如已经注册测试计划以获得对功能的早期访问权的用户，或者是一个随机样本，以便他们可以在全球发布之前及早发现问题。

Some big companies use regional access as well, where some features are enabled in certain countries first.

一旦特性标志被激活，任何不推荐使用的特性都可以被移除和清理，所以没有旧代码不会被使用。

# 处理数据库迁移

数据库迁移是对存储在特定环境(通常是一个或多个数据库)中的持久数据所做的更改。大多数情况下，这意味着更改数据库模式，但也有其他情况。

The data in a production environment is the most important asset in a running system. Extra care is advised for database migrations.

In certain cases, a migration may lock a table for a certain period of time, thereby rendering the system unusable. Ensure that you test your migrations properly in order to avoid or at least prepare for these cases.

虽然数据库迁移在技术上可能是可逆的，但是这样做在开发时间方面非常昂贵。例如，添加和删除列可能很简单，但是一旦该列开始运行，该列将包含不应删除的数据。

为了能够在数据迁移的情况下无缝工作，您需要将其从将要调用它的代码中分离出来，并按照以下步骤操作:

1.  以不干扰当前代码的方式设计数据库迁移。例如，向数据库添加表或列是安全的，因为旧代码会忽略它。
2.  执行数据库迁移。这将在现有代码保持不间断运行的同时进行所需的更改。
3.  现在，代码可以部署了。一旦部署完成，它将开始使用新数据库定义的优势。如果有问题，代码可以回滚到以前的版本。

这意味着我们需要创建两个部署:

*   一个用于迁移
*   另一个是使用这种迁移的代码

Migration deployment may be similar to code deployment. Maybe there's a microservice running the migrations, or maybe it's a script doing all the work. Most frameworks will have a way of making migrations to ensure that a migration isn't applied twice.

For example, for SQLAlchemy, there's a tool called Alembic ([https://alembic.sqlalchemy.org/en/latest/](https://alembic.sqlalchemy.org/en/latest/)) that we can use to generate and run migrations.

但是，还有一种替代操作:尝试将迁移应用到将使用它们的微服务。在处理生产环境时，这是一个坏主意，因为无论是否正在进行迁移，这都会减慢所有情况下的启动时间。此外，它不会检查代码是否可以安全地回滚并与数据库的早期版本一起工作。

使用两个独立的部署显然比自由地更改数据库要严格一些，但是它确保了每一步都是坚实的，并且服务是不间断的。比较刻意。例如，要重命名一个列，我们需要执行以下步骤:

1.  首先，我们将部署一个迁移，用新的列名创建一个新的列，从而复制旧列中的数据。代码从旧列读取和写入。
2.  然后，我们将部署从旧列读取并写入两者的新代码。在发布过程中，从旧代码到旧列的任何写入都将被正确读取。
3.  之后，我们将创建另一个迁移，将数据从旧的迁移复制到新的迁移。这可确保正确应用任何临时副本。此时，任何新数据仍会同时进入两列。
4.  然后，我们将部署读写新列的代码，忽略旧列。
5.  最后，我们将实现一个迁移来删除旧的列。此时，旧列不包含相关数据，可以安全删除。不会影响代码。

这是一个长过程的故意的例子，但是在大多数情况下，这样长的过程是不需要的。然而，在这些步骤中，没有任何一点是不一致的。如果其中一个阶段出现问题，我们可以回到上一个阶段——在修复到位之前，它仍然有效。

主要目标是避免数据库无法与当前部署的代码一起工作的短暂状态。

# 摘要

在本章中，我们讨论了团队的流程，从开始一项新功能到将其部署到生产环境中。

我们首先讨论了在微服务架构中工作时功能请求的要点。我们引入了影响多个微服务的请求，并学习了如何组织工作，以便服务不会被中断。

我们讨论了构成一个好的审查和批准过程的要素，以及 GitHub 拉取请求如何帮助我们做到这一点。使用 GitOps 实践来控制基础设施使得部署的审查变得简单明了。

然后，我们讨论了与 Kubernetes 和 GitOps 的合作如何帮助我们创建多个环境，以及在处理演示和试运行环境以测试部署以及在投入生产前在受控环境中展示功能时，我们如何利用它们来发挥我们的优势。

在这之后，我们讨论了如何让一个团队拥有整个生命周期的全局视图，从功能请求到部署，并能够快速遵循完整的路径。我们学习了如何阐明这些步骤，以及如何让团队负责审查和批准自己的代码，这允许开发人员完全掌控开发周期。

我们还讨论了在处理数据库迁移时可能出现的问题，并解释了如何继续这种不容易回滚的特殊部署。

在下一章中，我们将讨论实时系统，以及如何启用指标和日志等元素，以便我们能够检测生产环境中出现的问题和错误，并获得足够的信息来尽可能快速、主动地修复它们。

# 问题

1.  当一个新的业务特性被接收时，我们需要在微服务架构下的系统中执行什么分析？
2.  如果一个特性需要更改两个或更多的微服务，我们如何决定先更改哪个？
3.  Kubernetes 如何帮助我们设置多个环境？
4.  代码审查是如何工作的？
5.  代码评审的主要瓶颈是什么？
6.  在 GitOps 原则下，部署的评审和代码评审是不同的吗？
7.  为什么一旦一个特性准备好合并到主分支中，就要有一个清晰的部署路径？
8.  为什么数据库迁移不同于常规代码部署？

# 进一步阅读

要了解更多关于敏捷实践的知识并将其介绍给团队，请阅读以下书籍:

*   *敏捷开发人员手册*(T2)
*   *提炼出的敏捷技术实践*([https://www . packtpub . com/eu/business-other/Agile-技术实践-提炼出的](https://www.packtpub.com/eu/business-other/agile-technical-practices-distilled))

如果你在你的组织中使用 JIRA，阅读*与 JIRA 一起实践敏捷软件开发*([https://www . packtpub . com/eu/application-Development/Hands-Agile-Software-Development-jira](https://www.packtpub.com/eu/application-development/hands-agile-software-development-jira))可以帮助你在使用敏捷实践时更好地利用工具。