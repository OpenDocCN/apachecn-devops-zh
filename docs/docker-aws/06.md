# 六、构建定制的 ECS 容器实例

在前面的章节中，您学习了如何使用亚马逊 ECS 优化的亚马逊机器映像(AMI)来创建 ECS 容器实例，并通过几个简单的步骤将它们加入到 ECS 集群中。尽管 ECS 优化的 AMI 非常适合快速启动和运行，但您可能希望为生产环境的 ECS 容器实例添加额外的功能，例如添加日志代理或包括对 HTTP 代理的支持，以便您可以将 ECS 集群放在专用子网中。

在本章中，您将学习如何构建您自己的自定义 ECS 容器实例，使用 ECS 优化的 AMI 作为基础机器映像，并使用一个流行的开源工具 Packer 应用您自己的自定义。您将扩展基础映像以包括 AWS CloudWatch 日志代理，该代理支持使用 CloudWatch 日志服务从您的 ECS 容器实例进行集中日志记录，并安装一组有用的 CloudInfoformation 帮助脚本，称为 cfn-bootstrap，它将允许您在实例创建时运行强大的初始化脚本，并提供与 CloudInfoformation 的强大集成功能。

最后，您将创建一个第一次运行的脚本，该脚本允许您根据目标环境的具体情况调整实例，而无需为每个应用和环境构建新的 AMI。此脚本将使您能够有条件地启用 HTTP 代理支持，允许您在更安全的专用子网中安装您的 ECS 容器实例，并且还将包括运行状况检查，该检查将等到您的 ECS 容器实例已向其配置的 ECS 群集注册，然后向云信息发出您的实例已成功初始化的信号。

将涵盖以下主题:

*   设计定制的 AMI
*   使用 Packer 构建定制的 AMI
*   创建自定义存储配置
*   安装云信息帮助程序脚本
*   安装云监视日志代理
*   创建第一次运行脚本
*   测试您的自定义 ECS 容器实例

# 技术要求

下面列出了完成本章的技术要求:

*   封隔器 1.0 或更高版本(将提供如何安装封隔器的说明)
*   对 AWS 帐户的管理员访问权限
*   根据第 3 章中的说明配置本地 AWS 配置文件
*   GNU Make 版或更高版本(请注意，默认情况下，macOS 不附带此版本)
*   AWS CLI 1.15.71 或更高版本

此 GitHub URL 包含本章使用的代码示例:[https://GitHub . com/docker-in-AWS/docker-in-AWS/tree/master/ch6](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch6)[。](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch4)

查看以下视频，了解《行动守则》:
[http://bit.ly/2LzoxaO](http://bit.ly/2LzoxaO)

# 设计定制的亚马逊机器映像

在学习如何构建定制的亚马逊机器映像之前，了解*为什么*想要或需要构建自己的定制映像是很重要的。

这种情况的原因因您的用例或组织需求而异，但是一般来说，您可能需要构建自定义映像的原因有很多:

*   **自定义存储配置**:默认的 ECS 优化 AMI 附带一个 30 GB 的卷，其中包括用于操作系统分区的 8 GB 卷和用于存储 Docker 映像和容器文件系统的 22 GB 卷。我通常建议您更改配置的一个方面是，默认情况下，不使用分层文件系统的 Docker 卷存储在 8 GB 操作系统分区上。对于生产用例，通常应该避免这种方法，相反，您应该安装一个专用卷来存储 Docker 卷。
*   **附加包和工具的安装**:为了与 Docker 的极简主义理念保持一致，ECS 优化的 AMI 附带了最低限度的 Amazon Linux 安装，该安装仅包括运行 Docker Engine 和支持 ECS 代理所需的核心组件。对于实际的用例，至少，您通常希望将 CloudWatch 日志代理添加到 AWS CloudWatch 日志服务中，该代理支持系统级别的日志记录(例如，操作系统、Docker 引擎和 ECS 代理日志)。您应该考虑安装的另一组重要工具是 cfn-bootstrap 工具，它提供了一组 cloud information 帮助器脚本，您可以使用这些脚本在 cloud information 模板中为实例定义自定义配置操作，并且还允许 EC2 实例在配置和实例初始化完成后向 cloud information 发出信号。
*   **添加首次运行脚本**:将 ECS 容器实例部署到 AWS 时，您可能会在各种用例中使用它们，这些用例需要根据应用的性质进行不同的配置。例如，一个常见的安全最佳实践是将您的 ECS 容器实例部署到没有连接默认路由的专用子网中。这意味着您的 ECS 容器实例必须配置有 HTTP 代理，以便与 AWS 服务(如 ECS 和 CloudWatch 日志)或 ECS 容器实例可能依赖的任何其他互联网服务进行通信。但是，在某些情况下，使用 HTTP 代理可能不可行(例如，考虑运行为您的环境提供 HTTP 代理服务的 ECS 容器的 ECS 容器实例)，您可以创建仅在实例创建时运行一次的预配脚本，根据目标用例有条件地启用/禁用所需的配置，如 HTTP 代理设置，而不是构建单独的机器映像(一个启用了 HTTP 代理，一个未启用 HTTP 代理)。

当然，还有一大堆其他用例可能会促使您构建自己的自定义映像，但是在本章中，我们将重点关注这里定义的用例示例，这将为您提供坚实的基础，并让您了解如何应用您可能想要使用的任何其他自定义。

# 使用 Packer 构建定制的 AMI

现在您已经理解了构建自定义 ECS 容器实例映像的基本原理，让我们介绍一个名为 Packer 的工具，它允许您为包括 AWS 在内的各种平台构建机器映像。

**Packer** 是由 HashiCorp 创建的开源工具，你可以在[https://www.packer.io/](https://www.packer.io/)找到更多关于它的信息。Packer 可以为各种各样的目标平台构建机器映像，但是在本章中，我们将只关注构建亚马逊机器映像。

# 安装封隔器

在开始使用 Packer 之前，您需要在本地环境中安装它。Linux、mac OS 和 Windows 平台都支持 Packer，要为您的目标平台安装 Packer，请遵循位于[https://www.packer.io/intro/getting-started/install.html](https://www.packer.io/intro/getting-started/install.html)的说明。

请注意，操作系统和第三方包管理工具广泛支持 Packer——例如，在 mac OS 上，您可以通过运行`brew install packer`使用 Brew 包管理器安装 Packer。

# 创建打包模板

安装 Packer 后，您现在可以开始创建 Packer 模板，该模板将定义如何构建您的自定义机器映像。在您这样做之前，我建议为您的 Packer 模板创建一个单独的存储库，它应该始终处于版本控制之下，就像应用源代码和其他基础设施一样，作为代码存储库。

对于本章，我将假设您已经创建了一个名为`packer-ecs`的存储库，您可以参考位于[https://github.com/docker-in-aws/docker-in-aws](https://github.com/docker-in-aws/docker-in-aws)的`ch6`文件夹，该文件夹提供了一个基于本章内容的示例存储库。

# 封隔器模板结构

打包器模板是 JSON 文档，它提供了一个声明性描述，告诉打包器如何构建机器映像。

打包器模板围绕四个常见的顶级参数进行组织，如下例所示，并在此进行描述:

*   **变量**:为构建提供输入变量的对象。
*   **构建器**:定义目标机器映像平台的打包器构建器列表。在本章中，您将瞄准一个被称为 [EBS 支持的 AMI 构建器](https://www.packer.io/docs/builders/amazon-ebs.html)的构建器，它是创建定制亚马逊机器映像的最简单和最受欢迎的构建器。构建者负责确保正确的映像格式，并以适合部署到目标机器平台的格式发布最终映像。
*   **置备程序**:Packer 置备程序的列表或阵列，作为映像构建过程的一部分执行各种置备任务。最简单的置备程序包括文件和外壳置备程序，它们将文件复制到映像中并执行外壳任务，如安装软件包。
*   **后处理器**:Packer 后处理器的列表或数组，一旦构建并发布了机器映像，就执行后处理任务:

```
{
    "variables": {},
    "builders": [],
    "provisioners": [],
    "post-processors": []
}
```

Packer template structure

# 配置生成器

让我们开始配置我们的 Packer 模板，首先在 packer-ecs 存储库的根目录下创建一个名为`packer.json`的文件，然后定义构建器部分，如下例所示:

```
{
  "variables": {},
  "builders": [
 {
 "type": "amazon-ebs",
 "access_key": "{{user `aws_access_key_id`}}",
 "secret_key": "{{user `aws_secret_access_key`}}",
 "token": "{{user `aws_session_token`}}",
 "region": "us-east-1",
 "source_ami": "ami-5e414e24",
 "instance_type": "t2.micro",
 "ssh_username": "ec2-user",
 "associate_public_ip_address": "true",
 "ami_name": "docker-in-aws-ecs {{timestamp}}",
 "tags": {
 "Name": "Docker in AWS ECS Base Image 2017.09.h",
 "SourceAMI": "{{ .SourceAMI }}",
 "DockerVersion": "17.09.1-ce",
 "ECSAgentVersion": "1.17.0-2"
 }
 }
 ],
  "provisioners": [],
  "post-processors": []
}
```

Defining an EBS-backed AMI builder

在前面的例子中，一个代表构建器的对象被添加到构建器数组中。`type`参数将构建器定义为基于 EBS 的 AMI 构建器，以下设置特定于此类构建器:

*   `access_key`:定义在构建和发布 AMI 时，用于验证对 AWS 访问的 AWS 访问密钥 ID。
*   `secret_key`:定义在构建和发布 AMI 时，用于认证对 AWS 的访问的 AWS 机密访问密钥。
*   `token`:可选定义使用临时会话凭据进行身份验证时使用的 AWS 会话令牌。
*   `region`:目标 AWS 区域。
*   `source_ami`:要构建的源 AMI。在本例中，指定了在编写本报告时适用于美国东部 1 地区的最新 ECS-Optimated AMI 的源 AMI，您可以从[https://docs . AWS . Amazon . com/Amazon ECS/latest/developer guide/ECS-Optimated _ AMI . html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html)获得最新列表。
*   `instance_type`:用于构建 AMI 的实例类型。
*   `ssh_username`:Packer 在尝试连接到作为 Packer 构建过程的一部分创建的临时 EC2 实例时应该使用的 SSH 用户名。对于基于亚马逊 Linux 的 AMI，如 ECS 优化 AMI，必须将其指定为`ec2-user`用户。
*   `associate_public_ip_address`:设置为 true 时，将公共 IP 地址与实例相关联。如果您通过互联网使用 Packer，并且没有专用网络来访问作为 Packer 构建过程的一部分而创建的临时 EC2 实例，则需要这样做。
*   `ami_name`:将要创建的 AMI 的名称。该名称必须是唯一的，确保唯一性的常见方法是使用`{{timestamp}}` Go 模板功能，该功能将被 Packer 自动替换为当前时间戳。
*   `tags`:要添加到创建的 AMI 中的标签列表。这允许您附加元数据，例如映像的源 AMI、ECS 代理版本、Docker 版本或您可能发现有用的任何其他信息。请注意，您可以引用一个名为`SourceAMI`的特殊模板变量，它是由亚马逊 EBS 构建器添加的，并且基于`source_ami`变量的值。

中需要注意的一点是，与其将您的 AWS 凭据硬编码到模板中失败，不如引用一个名为`{{user `<variable-name>`}}`的 Go 模板函数，这将注入我们稍后将配置的顶层变量参数中定义的用户变量。

Packer templates are processed using Go's templating language, which you can read more about at [https://golang.org/pkg/text/template/](https://golang.org/pkg/text/template/). Go templates allow you to define your own template functions and Packer includes a number of useful functions that are defined at [https://www.packer.io/docs/templates/engine.html](https://www.packer.io/docs/templates/engine.html). Template functions are invoked through template expressions, which are expressed in the handlebars style format: `{{<function> <parameters>}}`.

# 配置变量

变量用于在构建时将特定于用户或特定于环境的设置注入到模板中，这有助于使机器映像模板更加通用，并避免模板中凭据的硬编码。

回到上一个示例，您在定义 AWS 凭据设置时引用了用户变量，这些变量必须在 Packer 模板的变量部分中定义，如上一个示例所示:

```
{
  "variables": {
 "aws_access_key_id": "{{env `AWS_ACCESS_KEY_ID`}}",
 "aws_secret_access_key": "{{env `AWS_SECRET_ACCESS_KEY`}}",
 "aws_session_token": "{{env `AWS_SESSION_TOKEN`}}",
 "timezone": "US/Eastern"
 },
  "builders": [
    {
      "type": "amazon-ebs",
      "access_key": "{{user `aws_access_key_id`}}",
      "secret_key": "{{user `aws_secret_access_key`}}",
      "token": "{{user `aws_session_token`}}",
      "region": "us-east-1",
      "source_ami": "ami-5e414e24",
      "instance_type": "t2.micro",
      "ssh_username": "ec2-user",
      "associate_public_ip_address": "true",
      "ami_name": "docker-in-aws-ecs {{timestamp}}",
      "tags": {
        "Name": "Docker in AWS ECS Base Image 2017.09.h",
        "SourceAMI": "{{ .SourceAMI }}",
        "DockerVersion": "17.09.1-ce",
        "ECSAgentVersion": "1.17.0-2"
      }
    }
  ],
  "provisioners": [],
  "post-processors": []
}
```

Defining variables

在前面的示例中，请注意，您在构建器部分为 AWS 凭据设置定义了用户函数中引用的每个变量。例如，构建器部分将`access_key`设置定义为`{{user `aws_access_key_id`}}`，这又会引用变量部分中定义的`aws_access_key_id`变量。

每个变量依次引用`env`模板函数，该函数查找传递给该函数的环境变量的值。这意味着您可以按如下方式控制每个变量的值:

*   `aws_access_key_id`:使用`AWS_ACCESS_KEY_ID`环境变量配置
*   `aws_secret_access_key`:使用`AWS_SECRET_ACCESS_KEY`环境变量配置
*   `aws_session_token`:使用`AWS_SESSION_TOKEN`环境变量配置
*   `timezone`:默认值**美国/东方**配置。运行`packer build`命令时，通过设置`-var '<variable>=<value>'`标志(例如`-var 'timezone=US/Pacific'`，可以覆盖默认变量)

请注意，我们还没有在我们的 Packer 模板中定义`timezone`变量，因为您将在本章后面使用这个变量。

# 配置置备程序

置备程序是 Packer 模板的核心，构成了在定制和构建计算机映像时执行的各种内部置备操作。

Packer 支持多种不同类型的置备程序，包括流行的配置管理工具，如 Ansible 和 Puppet，您可以在[https://www.packer.io/docs/provisioners/index.html](https://www.packer.io/docs/provisioners/index.html)阅读更多关于不同类型置备程序的信息。

对于我们的机器映像，我们将只使用两种最基本的可用资源调配程序:

*   [外壳供应程序](https://www.packer.io/docs/provisioners/shell.html):使用外壳命令和脚本执行机器映像供应
*   [文件供应器](https://www.packer.io/docs/provisioners/file.html):将文件复制到机器映像中

作为对置备程序的介绍，让我们定义一个简单的 shell 置备程序来更新已安装的操作系统包，如下例所示:

```
{
  "variables": {
    "aws_access_key_id": "{{env `AWS_ACCESS_KEY_ID`}}",
    "aws_secret_access_key": "{{env `AWS_SECRET_ACCESS_KEY`}}",
    "aws_session_token": "{{env `AWS_SESSION_TOKEN`}}",
    "timezone": "US/Eastern"
  },
  "builders": [
    {
      "type": "amazon-ebs",
      "access_key": "{{user `aws_access_key_id`}}",
      "secret_key": "{{user `aws_secret_access_key`}}",
      "token": "{{user `aws_session_token`}}",
      "region": "us-east-1",
      "source_ami": "ami-5e414e24",
      "instance_type": "t2.micro",
      "ssh_username": "ec2-user",
      "associate_public_ip_address": "true",
      "ami_name": "docker-in-aws-ecs {{timestamp}}",
      "tags": {
        "Name": "Docker in AWS ECS Base Image 2017.09.h",
        "SourceAMI": "ami-5e414e24",
        "DockerVersion": "17.09.1-ce",
        "ECSAgentVersion": "1.17.0-2"
      }
    }
  ],
  "provisioners": [
 {
 "type": "shell",
 "inline": [
 "sudo yum -y -x docker\\* -x ecs\\* update"
 ] 
 }
 ],
  "post-processors": []
}
```

Defining an inline shell provisioner

前面示例中定义的置备程序使用`inline`参数来定义将在置备阶段执行的命令列表。在这种情况下，您正在运行`yum update`命令，这是亚马逊 Linux 系统上的默认包管理器，并更新所有安装的操作系统包。为确保您使用基本 ECS 优化 AMI 中包含的 Docker 和 ECS 代理包的推荐和测试版本，您可以使用`-x`标志排除以`docker`和`ecs`开头的包。

In the preceding example, the yum command will be executed as `sudo yum -y -x docker\* -x ecs\* update`. Because the back slash character (`\`) is used to as an escape character in JSON, in the preceding example, a double backslash (for example, `\\*`) is used to generate a literal back slash.

最后，请注意，您必须使用`sudo`命令运行所有 shell 配置命令，因为 Packer 正在以`ec2_user`用户的身份配置 EC2 实例，如构建器一节中所定义的。

# 配置后处理器

我们将介绍的 Packer 模板的最后一个结构组件是[后处理器](https://www.packer.io/docs/post-processors/index.html)，一旦您的机器映像被提供和构建，它就允许您执行操作。

后处理器可以用于本书范围之外的各种不同的用例，然而我喜欢使用的后处理器的一个简单例子是 [Manifest 后处理器](https://www.packer.io/docs/post-processors/manifest.html)，它输出一个 JSON 文件，列出 Packer 产生的所有工件。当您创建连续的交付管道，首先构建您的 Packer 映像，然后需要测试和部署您的映像时，这个输出会非常有用。

在这个场景中，清单文件可以用作 Packer 构建的输出工件，描述与您的新机器映像相关联的区域和 AMI 标识符，并作为一个示例用作 CloudFormation 模板的输入，该模板将新机器映像部署到测试环境中。

以下示例演示了如何将清单后处理器添加到您的 Packer 模板中:

```
{
  "variables": {
    "aws_access_key_id": "{{env `AWS_ACCESS_KEY_ID`}}",
    "aws_secret_access_key": "{{env `AWS_SECRET_ACCESS_KEY`}}",
    "aws_session_token": "{{env `AWS_SESSION_TOKEN`}}",
    "timezone": "US/Eastern"
  },
  "builders": [
    {
      "type": "amazon-ebs",
      "access_key": "{{user `aws_access_key_id`}}",
      "secret_key": "{{user `aws_secret_access_key`}}",
      "token": "{{user `aws_session_token`}}",
      "region": "us-east-1",
      "source_ami": "ami-5e414e24",
      "instance_type": "t2.micro",
      "ssh_username": "ec2-user",
      "associate_public_ip_address": "true",
      "ami_name": "docker-in-aws-ecs {{timestamp}}",
      "tags": {
        "Name": "Docker in AWS ECS Base Image 2017.09.h",
        "SourceAMI": "ami-5e414e24",
        "DockerVersion": "17.09.1-ce",
        "ECSAgentVersion": "1.17.0-2"
      }
    }
  ],
  "provisioners": [
    {
      "type": "shell",
      "inline": [
        "sudo yum -y -x docker\\* -x ecs\\* update"
      ] 
    }
  ],
  "post-processors": [
 {
 "type": "manifest",
 "output": "manifest.json",
 "strip_path": true
 }
 ]
}
```

Defining a manifest post-processor

如您在前面的示例中所见，清单后处理器非常简单-`output`参数指定清单将被本地写入的文件的名称，而`strip_path`参数为任何构建的工件剥离任何本地文件系统路径信息。

# 构建机器映像

在这一点上，您已经创建了一个简单的 Packer 映像，它在定制方面表现不太好，但是仍然是一个可以构建的完整模板。

在实际运行构建之前，您需要确保您的本地环境配置正确，以便构建成功完成。回想一下在前面的示例中，您为模板定义了引用环境变量的变量，这些变量配置了您的 AWS 凭据，这里的一种常见方法是将您的本地 AWS 访问密钥 ID 和机密访问密钥设置为环境变量。

然而，在我们的用例中，我假设您使用的是前面章节中介绍的多因素身份验证的最佳实践方法，因此您的模板被配置为使用临时会话凭据，如`aws_session_token`输入变量所示，该变量需要在运行您的 Packer 构建之前动态生成并注入到您的本地环境中。

# 正在生成动态会话凭据

要生成临时会话凭据，假设您已经使用`AWS_PROFILE`环境变量配置了适当的配置文件，您可以运行`aws sts assume-role`命令来生成凭据:

```
> export AWS_PROFILE=docker-in-aws
> aws sts assume-role --role-arn=$(aws configure get role_arn) --role-session-name=$(aws configure get role_session_name)
Enter MFA code for arn:aws:iam::385605022855:mfa/justin.menga: ******
{
    "Credentials": {
        "AccessKeyId": "ASIAIIEUKCAR3NMIYM5Q",
        "SecretAccessKey": "JY7HmPMf/tPDXsgQXHt5zFZObgrQJRvNz7kb4KDM",
        "SessionToken": "FQoDYXdzEM7//////////wEaDP0PBiSeZvJ9GjTP5yLwAVjkJ9ZCMbSY5w1EClNDK2lS3nkhRg34/9xVgf9RmKiZnYVywrI9/tpMP8LaU/xH6nQvCsZaVTxGXNFyPz1BcsEGM6Z2ebIFX5rArT9FWu3v7WVs3QQvXeDTasgdvq71eFs2+qX7zbjK0YHXaWuu7GA/LGtNj4i+yi6EZ3OIq3hnz3+QY2dXL7O1pieMLjfZRf98KHucUhiokaq61cXSo+RJa3yuixaJMSxJVD1myx/XNritkawUfI8Xwp6g6KWYQAzDYz3MIWbA5LyX9Q0jk3yXTRAQOjLwvL8ZK/InJCDoPBFWFJwrz+Wxgep+I8iYoijOhqTUBQ==",
        "Expiration": "2018-02-18T05:38:38Z"
    },
    "AssumedRoleUser": {
        "AssumedRoleId": "AROAJASB32NFHLLQHZ54S:justin.menga",
        "Arn": "arn:aws:sts::385605022855:assumed-role/admin/justin.menga"
    }
}
> export AWS_ACCESS_KEY_ID="ASIAIIEUKCAR3NMIYM5Q"
> export AWS_SECRET_ACCESS_KEY="JY7HmPMf/tPDXsgQXHt5zFZObgrQJRvNz7kb4KDM"
> export AWS_SESSION_TOKEN="FQoDYXdzEM7//////////wEaDP0PBiSeZvJ9GjTP5yLwAVjkJ9ZCMbSY5w1EClNDK2lS3nkhRg34/9xVgf9RmKiZnYVywrI9/tpMP8LaU/xH6nQvCsZaVTxGXNFyPz1BcsEGM6Z2ebIFX5rArT9FWu3v7WVs3QQvXeDTasgdvq71eFs2+qX7zbjK0YHXaWuu7GA/LGtNj4i+yi6EZ3OIq3hnz3+QY2dXL7O1pieMLjfZRf98KHucUhiokaq61cXSo+RJa3yuixaJMSxJVD1myx/XNritkawUfI8Xwp6g6KWYQAzDYz3MIWbA5LyX9Q0jk3yXTRAQOjLwvL8ZK/InJCDoPBFWFJwrz+Wxgep+I8iYoijOhqTUBQ=="
```

Generating temporary session credentials

在前面的示例中，请注意，您可以使用 bash 替换来使用`aws configure get <parameter>`命令从您的 AWS CLI 配置文件中动态获取`role_arn`和`role_session_name`参数，这些参数是生成临时会话凭据时必需的输入。

前面示例的输出包括一个凭据对象，该对象包含映射到 Packer 模板中引用的环境变量的以下值:

*   **访问键标识**:该值作为`AWS_ACCESS_KEY_ID`环境变量导出
*   **SecretAccessKey** :该值作为`AWS_SECRET_ACCESS_KEY`环境变量导出
*   **会话设置**:该值作为`AWS_SESSION_TOKEN`环境变量导出

# 自动生成动态会话凭据

尽管您可以使用前面示例中演示的方法根据需要生成临时会话凭据，但这种方法很快就会变得令人厌烦。有许多方法可以将生成的临时会话凭据自动注入到您的环境中，但是鉴于本书使用 Make 作为自动化工具，下面的示例演示了如何使用相当简单的 Makefile 来实现这一点:

```
.PHONY: build
.ONESHELL:

build:
  @ $(if $(AWS_PROFILE),$(call assume_role))
  packer build packer.json

# Dynamically assumes role and injects credentials into environment
define assume_role
  export AWS_DEFAULT_REGION=$$(aws configure get region)
  eval $$(aws sts assume-role --role-arn=$$(aws configure get role_arn) \
    --role-session-name=$$(aws configure get role_session_name) \
    --query "Credentials.[ \
        [join('=',['export AWS_ACCESS_KEY_ID',AccessKeyId])], \
        [join('=',['export AWS_SECRET_ACCESS_KEY',SecretAccessKey])], \
        [join('=',['export AWS_SESSION_TOKEN',SessionToken])] \
      ]" \
    --output text)
endef
```

Generating temporary session credentials automatically using Make Ensure all indentation in your Makefile is performed using tabs rather than spaces.

在前面的例子中，请注意引入了一个名为`.ONESHELL`的指令。该指令将 Make 配置为为给定 Make 配方中定义的所有命令生成一个外壳，这意味着 bash 变量分配和环境设置可以跨多行重用。

如果当前环境配置了`AWS_PROFILE`，则`build`任务有条件地调用名为`assume_role`的函数，这种方法非常有用，因为这意味着如果您在一个构建代理上运行这个 Makefile，该代理被配置为以不同的方式获取 AWS 凭据，则不会动态生成临时会话凭据。

When a command is prefixed with the `@` symbol in a Makefile, the executed command will not output to stdout, and instead only the output of the command will be displayed.

`assume_role`函数使用高级 JMESPath 查询表达式(由`--query`标志指定)来生成一组`export`语句，这些语句引用您在前面示例中运行的命令的**凭证**字典输出上的各种属性，并使用 JMESPath 连接函数([http://JMESPath . read docs . io/en/latest/specification . html # join](http://jmespath.readthedocs.io/en/latest/specification.html#join))将这些值分配给相关的环境变量。这包含在命令替换中，使用`eval`命令执行每个输出`export`语句。如果您不理解这个查询，请不要太担心，但是要认识到 AWS 命令行界面确实包含强大的查询语法，可以创建一些非常复杂的命令行。

Note in the preceding example that you can use back ticks (```) as an alternative syntax for bash command substitutions. In other words, `$(command)` and ``command`` both represent command substitutions that will execute the command and return the output.

# 塑造形象

现在我们有了一个自动生成临时会话凭证的机制，假设您的`packer.json`文件和 Makefile 位于您的 packer-ecs 存储库的根目录下，让我们通过运行`make build`来测试构建您的 packer 映像:

```
> export AWS_PROFILE=docker-in-aws
> make build
Enter MFA code for arn:aws:iam::385605022855:mfa/justin.menga: ******
packer build packer.json
amazon-ebs output will be in this color.

==> amazon-ebs: Prevalidating AMI Name: docker-in-aws-ecs 1518934269
    amazon-ebs: Found Image ID: ami-5e414e24
==> amazon-ebs: Creating temporary keypair: packer_5a8918fd-018d-964f-4ab3-58bff320ead5
==> amazon-ebs: Creating temporary security group for this instance: packer_5a891904-2c84-aca1-d368-8309f215597d
==> amazon-ebs: Authorizing access to port 22 from 0.0.0.0/0 in the temporary security group...
==> amazon-ebs: Launching a source AWS instance...
==> amazon-ebs: Adding tags to source instance
    amazon-ebs: Adding tag: "Name": "Packer Builder"
    amazon-ebs: Instance ID: i-04c150456ac0748aa
==> amazon-ebs: Waiting for instance (i-04c150456ac0748aa) to become ready...
==> amazon-ebs: Waiting for SSH to become available...
==> amazon-ebs: Connected to SSH!
==> amazon-ebs: Provisioning with shell script: /var/folders/s4/1mblw7cd29s8xc74vr3jdmfr0000gn/T/packer-shell190211980
    amazon-ebs: Loaded plugins: priorities, update-motd, upgrade-helper
    amazon-ebs: Resolving Dependencies
    amazon-ebs: --> Running transaction check
    amazon-ebs: ---> Package elfutils-libelf.x86_64 0:0.163-3.18.amzn1 will be updated
    amazon-ebs: ---> Package elfutils-libelf.x86_64 0:0.168-8.19.amzn1 will be an update
    amazon-ebs: ---> Package python27.x86_64 0:2.7.12-2.121.amzn1 will be updated
    amazon-ebs: ---> Package python27.x86_64 0:2.7.13-2.122.amzn1 will be an update
    amazon-ebs: ---> Package python27-libs.x86_64 0:2.7.12-2.121.amzn1 will be updated
    amazon-ebs: ---> Package python27-libs.x86_64 0:2.7.13-2.122.amzn1 will be an update
    amazon-ebs: --> Finished Dependency Resolution
    amazon-ebs:
    amazon-ebs: Dependencies Resolved
    amazon-ebs:
    amazon-ebs: ================================================================================
    amazon-ebs: Package Arch Version Repository Size
    amazon-ebs: ================================================================================
    amazon-ebs: Updating:
    amazon-ebs: elfutils-libelf x86_64 0.168-8.19.amzn1 amzn-updates 313 k
    amazon-ebs: python27 x86_64 2.7.13-2.122.amzn1 amzn-updates 103 k
    amazon-ebs: python27-libs x86_64 2.7.13-2.122.amzn1 amzn-updates 6.8 M
    amazon-ebs:
    amazon-ebs: Transaction Summary
    amazon-ebs: ================================================================================
    amazon-ebs: Upgrade 3 Packages
    amazon-ebs:
    amazon-ebs: Total download size: 7.2 M
    amazon-ebs: Downloading packages:
    amazon-ebs: --------------------------------------------------------------------------------
    amazon-ebs: Total 5.3 MB/s | 7.2 MB 00:01
    amazon-ebs: Running transaction check
    amazon-ebs: Running transaction test
    amazon-ebs: Transaction test succeeded
    amazon-ebs: Running transaction
    amazon-ebs: Updating : python27-2.7.13-2.122.amzn1.x86_64 1/6
    amazon-ebs: Updating : python27-libs-2.7.13-2.122.amzn1.x86_64 2/6
    amazon-ebs: Updating : elfutils-libelf-0.168-8.19.amzn1.x86_64 3/6
    amazon-ebs: Cleanup : python27-2.7.12-2.121.amzn1.x86_64 4/6
    amazon-ebs: Cleanup : python27-libs-2.7.12-2.121.amzn1.x86_64 5/6
    amazon-ebs: Cleanup : elfutils-libelf-0.163-3.18.amzn1.x86_64 6/6
    amazon-ebs: Verifying : python27-libs-2.7.13-2.122.amzn1.x86_64 1/6
    amazon-ebs: Verifying : elfutils-libelf-0.168-8.19.amzn1.x86_64 2/6
    amazon-ebs: Verifying : python27-2.7.13-2.122.amzn1.x86_64 3/6
    amazon-ebs: Verifying : python27-libs-2.7.12-2.121.amzn1.x86_64 4/6
    amazon-ebs: Verifying : elfutils-libelf-0.163-3.18.amzn1.x86_64 5/6
    amazon-ebs: Verifying : python27-2.7.12-2.121.amzn1.x86_64 6/6
    amazon-ebs:
    amazon-ebs: Updated:
    amazon-ebs: elfutils-libelf.x86_64 0:0.168-8.19.amzn1
    amazon-ebs: python27.x86_64 0:2.7.13-2.122.amzn1
    amazon-ebs: python27-libs.x86_64 0:2.7.13-2.122.amzn1
    amazon-ebs:
    amazon-ebs: Complete!
==> amazon-ebs: Stopping the source instance...
    amazon-ebs: Stopping instance, attempt 1
==> amazon-ebs: Waiting for the instance to stop...
==> amazon-ebs: Creating the AMI: docker-in-aws-ecs 1518934269
    amazon-ebs: AMI: ami-57415b2d
==> amazon-ebs: Waiting for AMI to become ready...
==> amazon-ebs: Adding tags to AMI (ami-57415b2d)...
==> amazon-ebs: Tagging snapshot: snap-0bc767fd982333bf8
==> amazon-ebs: Tagging snapshot: snap-0104c1a352695c1e9
==> amazon-ebs: Creating AMI tags
    amazon-ebs: Adding tag: "SourceAMI": "ami-5e414e24"
    amazon-ebs: Adding tag: "DockerVersion": "17.09.1-ce"
    amazon-ebs: Adding tag: "ECSAgentVersion": "1.17.0-2"
    amazon-ebs: Adding tag: "Name": "Docker in AWS ECS Base Image 2017.09.h"
==> amazon-ebs: Creating snapshot tags
==> amazon-ebs: Terminating the source AWS instance...
==> amazon-ebs: Cleaning up any extra volumes...
==> amazon-ebs: No volumes to clean up, skipping
==> amazon-ebs: Deleting temporary security group...
==> amazon-ebs: Deleting temporary keypair...
==> amazon-ebs: Running post-processor: manifest
Build 'amazon-ebs' finished.

==> Builds finished. The artifacts of successful builds are:
--> amazon-ebs: AMIs were created:
us-east-1: ami-57415b2d
```

Running a Packer build

回到前面的例子和前面例子的输出，请注意在`build`任务中，构建 Packer 映像的命令只是`packer build <template-file>`，在本例中是`packer build packer.json`。

如果您查看前面示例的输出，您可以看到 Packer 执行了以下步骤:

*   Packer 首先验证源 AMI，然后生成临时 SSH 密钥对和安全组，以便能够访问临时 EC2 实例。
*   Packer 从源 AMI 启动一个临时 EC2 实例，然后等待，直到它能够建立 SSH 访问。
*   Packer 执行模板的置备程序部分中定义的置备操作。在这种情况下，您可以看到 yum `update`命令的输出，这是我们当前的单个供应操作。
*   一旦完成，Packer 将停止实例并创建 EBS 卷实例的快照，这将生成一个具有适当名称和 ID 的 AMI。
*   创建 AMI 后，Packer 终止实例，删除临时 SSH 密钥对和安全组，并输出新的 AMI ID。

回想一下前面的例子，您在模板中添加了一个清单后处理器，您应该会发现一个名为`manifest.json`的文件已经在您的存储库的根目录下输出，您通常不希望将其提交到您的 **packer-ecs** 存储库:

```
> cat manifest.json
{
  "builds": [
    {
      "name": "amazon-ebs",
      "builder_type": "amazon-ebs",
      "build_time": 1518934504,
      "files": null,
 "artifact_id": "us-east-1:ami-57415b2d",
      "packer_run_uuid": "db07ccb3-4100-1cc8-f0be-354b9f9b021d"
    }
  ],
  "last_run_uuid": "db07ccb3-4100-1cc8-f0be-354b9f9b021d"
}
> echo manifest.json >> .gitignore
```

Viewing the Packer build manifest

# 使用 Packer 构建定制的 ECS 容器实例映像

在前一节中，您使用 Packer 建立了用于构建自定义 AMI 的基础模板，并继续构建和发布您的第一个自定义 AMI。此时，您还没有执行任何特定于供应 ECS 容器实例的用例的定制，因此本节将着重于增强您的 Packer 模板以包括这样的定制。

您现在将了解的自定义包括以下内容:

*   定义自定义存储配置
*   安装附加软件包和配置操作系统设置
*   配置清理脚本
*   创建第一次运行脚本

有了这些定制，我们将通过构建您的最终定制 ECS 容器实例 AMI 并启动一个实例来验证各种定制来完成这一章。

# 定义自定义存储配置

AWS ECS 优化的 AMI 包括使用 30 GB EBS 卷的默认存储配置，该卷按如下方式分区:

*   `/dev/xvda`:一个 8 GB 的卷，作为根文件系统挂载，并作为操作系统分区。
*   `dev/xvdcz`:配置为逻辑卷管理(LVM)设备的 22 GB 卷，用于 Docker 映像和元数据存储。

The ECS-Optimized AMI uses the devicemapper storage driver for Docker image and metadata storage, which you can learn more about at [https://docs.docker.com/v17.09/engine/userguide/storagedriver/device-mapper-driver/](https://docs.docker.com/storage/storagedriver/device-mapper-driver/).

对于大多数使用情况，这种存储配置应该足够了，但是在一些情况下，您可能需要修改默认配置:

*   **您需要更多的 Docker 映像和元数据存储**:这可以通过简单地将您的 ECS 容器实例配置为更大的卷大小来轻松解决。默认存储配置将始终为操作系统和根文件系统保留 8GB，剩余的存储将分配给 Docker 映像和元数据存储。
*   **您需要支持具有大存储需求的 Docker 卷**:默认情况下，ECS 优化的 AMI 将 Docker 卷存储在`/var/lib/docker/volumes`，这是 8GB `/dev/xvda`分区上根文件系统的一部分。如果您有更大的卷需求，这可能会导致您的操作系统分区很快变满，因此在这种情况下，您应该将卷存储分离到单独的 EBS 卷。

现在让我们看看如何修改您的 Packer 模板，为 Docker 卷存储添加一个新的专用卷，并确保在创建实例时正确装载该卷。

# 添加 EBS 卷

要向您的自定义 AMIs 添加 EBS 卷，您可以在亚马逊 EBS 生成器中配置`launch_block_device_mappings`参数:

```
{
  "variables": {...},
  "builders": [
    {
      "type": "amazon-ebs",
      "access_key": "{{user `aws_access_key_id`}}",
      "secret_key": "{{user `aws_secret_access_key`}}",
      "token": "{{user `aws_session_token`}}",
      "region": "us-east-1",
      "source_ami": "ami-5e414e24",
      "instance_type": "t2.micro",
      "ssh_username": "ec2-user",
      "associate_public_ip_address": "true",
      "ami_name": "docker-in-aws-ecs {{timestamp}}",
      "launch_block_device_mappings": [
 {
 "device_name": "/dev/xvdcy",
 "volume_size": 20,
 "volume_type": "gp2",
 "delete_on_termination": true
 }
 ],
      "tags": {
        "Name": "Docker in AWS ECS Base Image 2017.09.h",
        "SourceAMI": "ami-5e414e24",
        "DockerVersion": "17.09.1-ce",
        "ECSAgentVersion": "1.17.0-2"
      }
    }
  ],
  "provisioners": [...],
  "post-processors": [...]
}
```

Adding a launch block device mapping

在前面的示例中，为了简洁起见，我截断了 Packer 模板的其他部分，您可以看到我们添加了一个名为`/dev/xvdcy`的 20 GB 卷，该卷被配置为在实例终止时销毁。请注意，`volume_type`参数设置为`gp2`，这是一种通用固态硬盘存储类型，通常在 AWS 中提供最佳的整体性价比。

# 格式化和装入卷

有了前面示例的配置，我们接下来需要格式化并装载这个新卷。因为我们使用了`launch_block_device_mappings`参数(与`ami_block_device_mappings`参数相反)，块设备实际上是在映像构建时附加的(后一个参数仅在映像创建时附加)，我们可以在构建时执行所有格式化和装载配置设置。

要执行此配置，我们将添加一个外壳程序，该程序将一个名为`scripts/storage.sh`的文件引用到您的 Packer 模板中:

```
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    {
 "type": "shell",
 "script": "scripts/storage.sh"
 },
    {
      "type": "shell",
      "inline": [
        "sudo yum -y -x docker\\* -x ecs\\* update"
      ] 
    }
  ],
  "post-processors": [...]
}
```

Adding a shell provisioner for configuring storage

被引用的脚本被表示为相对于 Packer 模板的路径，因此您现在需要创建这个脚本:

```
> mkdir -p scripts
> touch scripts/storage.sh
> tree
.
├── Makefile
├── manifest.json
├── packer.json
└── scripts
 └── storage.sh

1 directory, 4 files
```

Creating a scripts folder

有了脚本文件，您现在可以在该脚本中定义各种 shell 配置操作，如下例所示:

```
#!/usr/bin/env bash
set -e

echo "### Configuring Docker Volume Storage ###"
sudo mkdir -p /data
sudo mkfs.ext4 -L docker /dev/xvdcy
echo -e "LABEL=docker\t/data\t\text4\tdefaults,noatime\t0\t0" | sudo tee -a /etc/fstab
sudo mount -a
```

Storage provisioning script

正如您在前面的示例中所看到的，该脚本是一个常规的 bash 脚本，始终为您的所有 Packer shell 脚本(`set -e`)设置错误标志是很重要的，这确保了如果脚本中的任何命令失败，该脚本将带着错误代码退出。

首先创建一个名为`/data`的文件夹，用于存储 Docker 卷，然后用`.ext4`文件系统格式化前面示例中连接的`/dev/xvdcy`设备，并附加一个名为`docker`的标签，这使得装载操作更容易执行。下一个`echo`命令向`/etc/fstab`文件添加一个条目，该条目定义了将在引导时应用的所有文件系统挂载，请注意，您必须将`echo`命令传送到`sudo tee -a /etc/fstab`，这将把`echo`输出附加到具有正确 sudo 权限的`/etc/fstab`文件。

最后，您可以通过运行`mount -a`命令来自动装载`/etc/fstab`文件中的新条目，虽然在映像构建时不需要该命令，但这是一种验证装载是否实际配置正确的简单方法(如果没有，该命令将失败，最终构建将失败)。

# 安装附加软件包和配置系统设置

您将执行的下一个自定义是安装其他软件包和配置系统设置。

# 安装附加软件包

我们还需要在定制的 ECS 容器实例中安装一些额外的包，包括以下内容:

*   **cloud information 助手脚本**:当您使用 cloud information 来部署您的基础架构时，AWS 提供了一组 cloud information 助手脚本，统称为 **cfn-bootstrap** ，它们与 cloud information 一起工作，以获取初始化元数据，该元数据允许您在实例创建时执行自定义的初始化任务，并且还在实例成功完成初始化时向 cloud information 发出信号。我们将在后面的章节中探讨这种方法的好处，但是，现在您需要确保这些帮助脚本出现在您的自定义 ECS 容器实例映像中。
*   **CloudWatch 日志代理**:AWS cloud watch 日志服务提供来自各种来源的日志的集中存储，包括 EC2 实例、ECS 容器和其他 AWS 服务。要将您的 ECS 容器实例(EC2 实例)日志传送到 CloudWatch 日志，您必须在本地安装 CloudWatch 日志代理，然后可以使用该代理转发各种系统日志，包括操作系统、Docker 和 ECS 代理日志。
*   **`jq`实用程序**:实用程序([【https://stedolan.github.io/jq/manual/】](https://stedolan.github.io/jq/manual/))对于解析 JSON 输出很方便，当您定义一个简单的运行状况检查来验证 ECS 容器实例已经加入到配置的 ECS 集群时，您将在本章的后面需要这个实用程序。

安装这些附加包非常简单，可以通过修改您之前创建的内联 shell provisioner 来实现:

```
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    {
      "type": "shell",
      "script": "scripts/storage.sh"
    },
    {
      "type": "shell",
      "inline": [
        "sudo yum -y -x docker\\* -x ecs\\* update",
 "sudo yum -y install aws-cfn-bootstrap awslogs jq"
      ] 
    }
  ],
  "post-processors": [...]
}
```

Installing additional operating system packages

如您在前面的示例中所见，可以使用`yum`包管理器轻松安装所需的每个包。

# 配置系统设置

您需要对自定义 ECS 容器实例进行一些小的系统设置:

*   配置时区设置
*   修改默认云初始化行为

# 配置时区设置

之前，您定义了一个名为`timezone`的变量，到目前为止，您还没有在模板中引用它。您可以使用此变量来配置自定义 ECS 容器实例映像的时区。

为此，首先需要在 Packer 模板中添加一个新的 shell provisioner:

```
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    {
      "type": "shell",
      "script": "scripts/storage.sh"
    },
    {
 "type": "shell",
 "script": "scripts/time.sh",
 "environment_vars": [
 "TIMEZONE={{user `timezone`}}"
 ]
 },
    {
      "type": "shell",
      "inline": [
        "sudo yum -y -x docker\\* -x ecs\\* update",
        "sudo yum -y install aws-cfn-bootstrap awslogs jq"
      ] 
    }
  ],
  "post-processors": [...]
}
```

Adding a provisioner to configure time settings

在前面的示例中，我们引用了一个名为`scripts/time.sh`的脚本，您将很快创建该脚本，但是请注意，我们还包括一个名为`environment_vars`的参数，该参数允许您将您的 Packer 变量(在本例中为`timezone`)作为环境变量注入到您的 shell 供应脚本中。

以下示例显示了在新的 Packer 模板供应任务中引用的所需的`scripts/time.sh`脚本:

```
#!/usr/bin/env bash
set -e

# Configure host to use timezone
# http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html
echo "### Setting timezone to $TIMEZONE ###"
sudo tee /etc/sysconfig/clock << EOF > /dev/null
ZONE="$TIMEZONE"
UTC=true
EOF

sudo ln -sf /usr/share/zoneinfo/"$TIMEZONE" /etc/localtime

# Use AWS NTP Sync service
echo "server 169.254.169.123 prefer iburst" | sudo tee -a /etc/ntp.conf

# Enable NTP
sudo chkconfig ntpd on
```

Time settings provisioning script

在上例中，首先配置 [AWS 推荐的配置时间设置](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html)，用配置的`TIMEZONE`环境变量配置`/etc/sysconfig/clock`文件，创建符号`/etc/localtime`链接，最后确保`ntpd`服务配置为使用 [AWS NTP 同步](https://aws.amazon.com/blogs/aws/keeping-time-with-amazon-time-sync-service/)服务，并在实例启动时启动。

The AWS NTP sync service is a free AWS service that provides an NTP server endpoint at the `169.254.169.123` local address, ensuring your EC2 instances can obtain accurate time without having to traverse the network or internet.

# 修改默认云初始化行为

cloud-init 是一组标准实用程序，用于执行云映像和相关实例的初始化。cloud-init 最受欢迎的特性是用户数据机制，这是一种在创建实例时运行您自己的自定义初始化命令的简单方法。

cloud-init 也用于 ECS-Optimized AMI 中，在实例创建时执行自动安全修补，虽然这听起来是一个有用的功能，但它可能会导致问题，尤其是在您的实例位于私有子网并且需要 HTTP 代理与互联网通信的环境中。

cloud-init 安全机制的问题是，尽管可以通过设置代理环境变量来配置它以使用 HTTP 代理，但它是在执行 userdata 之前调用的，这导致了先有鸡还是先有蛋的情况，如果使用代理，您别无选择，只能禁用自动安全修补。

要禁用此机制，您首先需要在 Packer 模板中配置一个新的 shell provisioner:

```
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    {
      "type": "shell",
      "script": "scripts/storage.sh"
    },
    {
      "type": "shell",
      "script": "scripts/time.sh",
      "environment_vars": [
        "TIMEZONE={{user `timezone`}}"
      ]
    },
    {
 "type": "shell",
 "script": "scripts/cloudinit.sh"
 },
    {
      "type": "shell",
      "inline": [
        "sudo yum -y -x docker\\* -x ecs\\* update",
        "sudo yum -y install aws-cfn-bootstrap awslogs jq"
      ] 
    }
  ],
  "post-processors": [...]
}
```

Adding a provisioner to configure cloud-init settings The referenced `scripts/cloudinit.sh` script can now be created as follows:

```
#!/usr/bin/env bash
set -e

# Disable cloud-init repo updates or upgrades
sudo sed -i -e '/^repo_update: /{h;s/: .*/: false/};${x;/^$/{s//repo_update: false/;H};x}' /etc/cloud/cloud.cfg
sudo sed -i -e '/^repo_upgrade: /{h;s/: .*/: none/};${x;/^$/{s//repo_upgrade: none/;H};x}' /etc/cloud/cloud.cfg
```

Disabling security updates for cloud-init

在下面的例子中，看起来相当恐怖的`sed`表达式将在`/etc/cloud/cloud.cfg` cloud-init 配置文件中添加或替换以`repo_update`和`repo_upgrade`开头的行，并确保它们分别设置为`false`和`none`。

# 配置清理脚本

至此，我们已经执行了所有必需的安装和配置 shell 配置任务。我们将创建最后一个 shell provisioner，一个清理脚本，它将删除用于构建自定义映像的实例运行时创建的任何日志文件，并确保机器映像处于准备启动的状态。

您首先需要向您的 Packer 模板添加一个外壳提供程序，该模板引用`scripts/cleanup.sh`脚本:

```
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    {
      "type": "shell",
      "script": "scripts/storage.sh"
    },
    {
      "type": "shell",
      "script": "scripts/time.sh",
      "environment_vars": [
        "TIMEZONE={{user `timezone`}}"
      ]
    },
    {
      "type": "shell",
      "script": "scripts/cloudinit.sh"
    },
    {
      "type": "shell",
      "inline": [
        "sudo yum -y -x docker\\* -x ecs\\* update",
        "sudo yum -y install aws-cfn-bootstrap awslogs jq"
      ] 
    },
 { "type": "shell",
 "script": "scripts/cleanup.sh"
 }
  ],
  "post-processors": [...]
}
```

Adding a provisioner to clean up the Image

使用 Packer 模板中定义的置备程序，接下来需要创建清理脚本，如下所述:

```
#!/usr/bin/env bash
echo "### Performing final clean-up tasks ###"
sudo stop ecs
sudo docker system prune -f -a
sudo service docker stop
sudo chkconfig docker off
sudo rm -rf /var/log/docker /var/log/ecs/*
```

Cleanup script

在下面的例子中，请注意您没有执行命令`set -e`，因为这是一个清理脚本，如果出现错误，您并不太担心，如果服务已经停止，您也不希望您的构建失败。首先停止 ECS 代理，使用`docker system prune`命令清除可能存在的任何 ECS 容器状态，然后停止 Docker 服务，然后使用`chkconfig`命令禁用。这样做的原因是，在创建实例时，我们将总是调用第一次运行的脚本，该脚本将执行实例的初始配置，并要求 Docker 服务停止。当然，这意味着一旦第一次运行的脚本已经完成了它的初始配置，它将负责确保 Docker 服务已经启动并能够在启动时启动。

最后，清理脚本会删除任何 Docker 和 ECS 代理日志文件，这些文件可能是在自定义机器映像构建过程中实例启动的短暂时间内创建的。

# 创建第一次运行脚本

我们将应用于您的自定义 ECS 容器实例映像的最后一组自定义是创建第一次运行脚本，该脚本将负责在实例创建时执行 ECS 容器实例的运行时配置，方法是执行以下任务:

*   配置 ECS 集群成员资格
*   配置 HTTP 代理支持
*   配置云监视日志代理
*   启动所需服务
*   执行健康检查

要调配第一次运行的脚本，您需要在 Packer 模板中定义一个文件调配器任务，如下所示:

```
{
  "variables": {...},
  "builders": [...],
  "provisioners": [
    {
      "type": "shell",
      "script": "scripts/storage.sh"
    },
    {
      "type": "shell",
      "script": "scripts/time.sh",
      "environment_vars": [
        "TIMEZONE={{user `timezone`}}"
      ]
    },
    {
      "type": "shell",
      "script": "scripts/cloudinit.sh"
    },
    {
      "type": "shell",
      "inline": [
        "sudo yum -y -x docker\\* -x ecs\\* update",
        "sudo yum -y install aws-cfn-bootstrap awslogs jq"
      ] 
    },
    {
      "type": "shell",
      "script": "scripts/cleanup.sh"
    },
    {
 "type": "file",
 "source": "files/firstrun.sh",
 "destination": "/home/ec2-user/firstrun.sh"
 }
  ],
  "post-processors": [...]
}
```

Adding a file provisioner

请注意，置备程序类型配置为`file`，并指定了需要位于`files/firstrun.sh`的本地源文件。`destination`参数定义了第一个运行脚本在 AMI 中的位置。请注意，文件供应器任务以`ec2-user`用户的身份复制文件，因此它对该脚本可以复制到哪里具有有限的权限。

# 配置 ECS 集群成员资格

现在，您可以在 Packer 模板引用的文件/firstrun.sh 位置创建第一次运行脚本。在开始配置此文件之前，一定要记住，第一次运行的脚本设计为在从您的自定义机器映像创建的实例的初始引导时运行，因此在配置将要执行的各种命令时，您必须考虑这一点。

我们将首先创建并配置 ECS 代理，以加入 ECS 容器实例打算加入的 ECS 集群，如下例所示:

```
#!/usr/bin/env bash
set -e

# Configure ECS Agent
echo "ECS_CLUSTER=${ECS_CLUSTER}" > /etc/ecs/ecs.config
```

Configuring ECS cluster membership

回到[第 5 章](05.html)、*使用 ECR* 发布 Docker 映像，您看到了 ECS 集群向导如何使用相同的方法配置 ECS 容器实例，尽管一个不同之处是脚本期望在环境中配置名为`ECS_CLUSTER`的环境变量，如`${ECS_CLUSTER}`表达式所指定的。不是硬编码 ECS 集群名称，这会使第一次运行的脚本非常不灵活，这里的想法是应用于给定实例的配置用正确的集群名称定义`ECS_CLUSTER`环境变量，这意味着脚本是可重用的，并且可以用任何给定的 ECS 集群进行配置。

# 配置 HTTP 代理支持

一个常见的安全最佳实践是将您的 ECS 容器实例放在私有子网中，这意味着它们位于没有默认互联网路由的子网中。这种方法使攻击者更难危害您的系统，即使他们危害了您的系统，也提供了一种手段来限制他们可以传输回互联网的信息。

根据您的应用的性质，您通常会要求您的 ECS 容器实例能够连接到互联网，并且使用 HTTP 代理提供了一种有效的机制，通过第 7 层应用层检查功能以受控的方式提供这种访问。

无论您的应用的性质如何，理解 ECS 容器实例出于以下目的需要互联网连接是很重要的:

*   ECS 代理与 ECS 的控制平面和管理平面通信
*   Docker 引擎与 ECR 和其他存储库的通信，用于下载 Docker 映像
*   CloudWatch 日志代理与 CloudWatch 日志服务的通信
*   云信息助手-与云信息服务的脚本通信

尽管配置完整的端到端代理解决方案超出了本书的范围，但了解如何自定义 ECS 容器实例以使用 HTTP 代理还是很有用的，如以下示例所示:

```
#!/usr/bin/env bash
set -e

# Configure ECS Agent
echo "ECS_CLUSTER=${ECS_CLUSTER}" > /etc/ecs/ecs.config

# Set HTTP Proxy URL if provided
if [ -n $PROXY_URL ]
then
 echo export HTTPS_PROXY=$PROXY_URL >> /etc/sysconfig/docker
 echo HTTPS_PROXY=$PROXY_URL >> /etc/ecs/ecs.config
 echo NO_PROXY=169.254.169.254,169.254.170.2,/var/run/docker.sock >> /etc/ecs/ecs.config
 echo HTTP_PROXY=$PROXY_URL >> /etc/awslogs/proxy.conf
 echo HTTPS_PROXY=$PROXY_URL >> /etc/awslogs/proxy.conf
 echo NO_PROXY=169.254.169.254 >> /etc/awslogs/proxy.conf
fi

```

Configuring HTTP proxy support

在前面的示例中，脚本检查名为`PROXY_URL`的非空环境变量的存在，如果存在，则继续为 ECS 容器实例的各个组件配置代理设置:

*   Docker引擎:通过`/etc/sysconfig/docker`配置
*   ECS 代理:通过`/etc/ecs/ecs.config`配置
*   云观察日志代理:通过`/etc/awslogs/proxy.conf`配置

请注意，在某些情况下，您需要配置`NO_PROXY`设置，该设置禁用以下 IP 地址的代理通信:

*   `169.254.169.254`:这是一个特殊的本地地址，用于与 EC2 元数据服务通信，以获取实例元数据，如 EC2 实例角色凭据。
*   `169.254.170.2`:这是一个特殊的本地地址，用于获取 ECS 任务凭证。

# 配置云监视日志代理

您将在第一次运行的脚本中执行的下一个配置任务是配置 CloudWatch 日志代理。在 ECS 容器实例上，CloudWatch 日志代理负责收集系统日志，如操作系统、Docker 和 ECS 代理日志。

Note that this agent is NOT required to implement CloudWatch logs support for your Docker containers - this is already implemented within the Docker Engine via the `awslogs` logging driver.

配置 CloudWatch 日志代理需要您执行以下配置任务:

*   **配置正确的 AWS 区域**:对于这个任务，您将注入一个名为`AWS_DEFAULT_REGION`的环境变量的值，并将其写入`/etc/awslogs/awscli.conf`文件。
*   **定义 CloudWatch 日志代理将登录到的各种日志组和日志流设置**:对于此任务，您将为 ECS 容器实例定义一组推荐的日志组，在[https://docs . AWS . Amazon . com/AmazonECS/latest/developer guide/using _ CloudWatch _ logs . html # configure _ cwl _ agent](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_cloudwatch_logs.html#configure_cwl_agent)中有描述

以下示例演示了所需的配置:

```
#!/usr/bin/env bash
set -e

# Configure ECS Agent
echo "ECS_CLUSTER=${ECS_CLUSTER}" > /etc/ecs/ecs.config

# Set HTTP Proxy URL if provided
if [ -n $PROXY_URL ]
then
  echo export HTTPS_PROXY=$PROXY_URL >> /etc/sysconfig/docker
  echo HTTPS_PROXY=$PROXY_URL >> /etc/ecs/ecs.config
  echo NO_PROXY=169.254.169.254,169.254.170.2,/var/run/docker.sock >> /etc/ecs/ecs.config
  echo HTTP_PROXY=$PROXY_URL >> /etc/awslogs/proxy.conf
  echo HTTPS_PROXY=$PROXY_URL >> /etc/awslogs/proxy.conf
  echo NO_PROXY=169.254.169.254 >> /etc/awslogs/proxy.conf
fi

# Write AWS Logs region
sudo tee /etc/awslogs/awscli.conf << EOF > /dev/null
[plugins]
cwlogs = cwlogs
[default]
region = ${AWS_DEFAULT_REGION}
EOF

# Write AWS Logs config
sudo tee /etc/awslogs/awslogs.conf << EOF > /dev/null
[general]
state_file = /var/lib/awslogs/agent-state 

[/var/log/dmesg]
file = /var/log/dmesg
log_group_name = /${STACK_NAME}/ec2/${AUTOSCALING_GROUP}/var/log/dmesg
log_stream_name = {instance_id} 
[/var/log/messages]
file = /var/log/messages
log_group_name = /${STACK_NAME}/ec2/${AUTOSCALING_GROUP}/var/log/messages
log_stream_name = {instance_id}
datetime_format = %b %d %H:%M:%S 
[/var/log/docker]
file = /var/log/docker
log_group_name = /${STACK_NAME}/ec2/${AUTOSCALING_GROUP}/var/log/docker
log_stream_name = {instance_id}
datetime_format = %Y-%m-%dT%H:%M:%S.%f 
[/var/log/ecs/ecs-init.log]
file = /var/log/ecs/ecs-init.log*
log_group_name = /${STACK_NAME}/ec2/${AUTOSCALING_GROUP}/var/log/ecs/ecs-init
log_stream_name = {instance_id}
datetime_format = %Y-%m-%dT%H:%M:%SZ
time_zone = UTC 
[/var/log/ecs/ecs-agent.log]
file = /var/log/ecs/ecs-agent.log*
log_group_name = /${STACK_NAME}/ec2/${AUTOSCALING_GROUP}/var/log/ecs/ecs-agent
log_stream_name = {instance_id}
datetime_format = %Y-%m-%dT%H:%M:%SZ
time_zone = UTC

[/var/log/ecs/audit.log]
file = /var/log/ecs/audit.log*
log_group_name = /${STACK_NAME}/ec2/${AUTOSCALING_GROUP}/var/log/ecs/audit.log
log_stream_name = {instance_id}
datetime_format = %Y-%m-%dT%H:%M:%SZ
time_zone = UTC
EOF
```

Configuring the CloudWatch logs agent

您可以看到，第一次运行的脚本在每个定义的日志组的`log_group_name`参数中包含了对环境变量的引用，这有助于确保您的 AWS 帐户中唯一的日志组命名:

*   `STACK_NAME`:云信息栈的名称
*   `AUTOSCALING_GROUP`:自动缩放组的名称

同样，这些环境变量必须在实例创建时注入到第一次运行的脚本中，因此在我们将学习如何做到这一点的未来章节中请记住这一点。

在前面的例子中需要注意的另一点是每个`log_stream_name`参数的值——这被设置为一个名为`{instance_id}`的特殊变量，CloudWatch 日志代理将使用该实例的 EC2 实例标识自动配置该变量。

最终结果是，您将获得每种日志类型的几个日志组，这些日志组的范围是给定的 CloudFormation 栈和 EC2 自动扩展组的上下文，在每个日志组中，将为每个 ECS 容器实例创建一个日志流，如下图所示:

![](img/a199eec7-ad83-4e86-bd90-ac0febe0df2f.png)

CloudWatch logs group configuration for ECS container instances

# 启动所需服务

回想一下前面的例子，您添加了一个清理脚本作为映像构建过程的一部分，它禁止 Docker Engine 服务在启动时启动。这种方法允许您在启动 Docker 引擎之前执行所需的初始化任务，在第一次运行脚本的这一点上，我们已经准备好启动 Docker 引擎和其他重要的系统服务:

```
#!/usr/bin/env bash
set -e

# Configure ECS Agent
echo "ECS_CLUSTER=${ECS_CLUSTER}" > /etc/ecs/ecs.config

# Set HTTP Proxy URL if provided
...
...

# Write AWS Logs region
...
...

# Write AWS Logs config
...
...

# Start services
sudo service awslogs start
sudo chkconfig docker on
sudo service docker start
sudo start ecs
```

Starting services

在前面的例子中，请注意，为了简洁起见，我省略了第一次运行脚本的前面部分。请注意，您首先启动 awslogs 服务，该服务确保 CloudWatch 日志代理将获取所有 Docker Engine 日志，然后继续启用 Docker 在启动时启动，启动 Docker，最后启动 ECS 代理。

# 执行所需的健康检查

我们在第一次运行的脚本中需要执行的最后一项任务是运行状况检查，它确保 ECS 容器实例已经初始化并成功注册到已配置的 ECS 集群。这是对您的 ECS 容器实例的合理运行状况检查，因为 ECS 代理只能在 Docker Engine 运行时运行，并且 ECS 代理必须在 ECS 集群中注册才能部署您的应用。

回想一下上一章，当您检查一个 ECS 容器实例的内部时，ECS 代理公开了一个本地 HTTP 端点，可以查询该端点的当前 ECS 代理状态。您可以使用该端点创建一个非常简单的运行状况检查，如下所示:

```
#!/usr/bin/env bash
set -e

# Configure ECS Agent
echo "ECS_CLUSTER=${ECS_CLUSTER}" > /etc/ecs/ecs.config

# Set HTTP Proxy URL if provided
...
...

# Write AWS Logs region
...
...

# Write AWS Logs config
...
...

# Start services
...
...

# Health check
# Loop until ECS agent has registered to ECS cluster
echo "Checking ECS agent is joined to ${ECS_CLUSTER}"
until [[ "$(curl --fail --silent http://localhost:51678/v1/metadata | jq '.Cluster // empty' -r -e)" == ${ECS_CLUSTER} ]]
 do printf '.'
 sleep 5
done
echo "ECS agent successfully joined to ${ECS_CLUSTER}"
```

Performing a health check

在前面的例子中，配置了一个 bash `until`循环，它使用 curl 每五秒查询一次`http://localhost:51678/v1/metadata`端点。该命令的输出通过管道传输到`jq`，如果该属性不存在，它将返回集群属性或空值。一旦 ECS 代理注册到正确的 ECS 集群并在 JSON 响应中返回该属性，循环将完成，第一次运行的脚本将完成。

# 测试您的自定义 ECS 容器实例映像

您现在已经完成了所有定制，是时候使用`packer build`命令重建您的映像了。在您这样做之前，现在是验证您是否有正确的 Packer 模板，以及是否已经创建了相关的支持文件的好时机。以下示例显示了您现在应该在 packer-ecs 存储库中拥有的文件夹和文件结构:

```
> tree
.
├── Makefile
├── files
│   └── firstrun.sh
├── manifest.json
├── packer.json
└── scripts
    ├── cleanup.sh
    ├── cloudinit.sh
    ├── storage.sh
    └── time.sh

2 directories, 8 files
```

Verifying the Packer repository

假设一切就绪，您现在可以通过运行`make build`命令再次运行您的 Packer 构建。

完成所有工作并成功创建您的 AMI 后，您现在可以在 AWS 控制台中查看您的 AMI，方法是导航至**服务** | **EC2** 并从左侧菜单中选择 AMI:

![](img/286a5d2f-7e98-467b-a671-5f3ad55eaf24.png)

EC2 dashboard AMIs

在前面的截图中，您可以看到您在本章前面和刚才构建的两个 AMIs。请注意，最新的 AMI 现在包括三个数据块设备，`/dev/xvdcy`代表您在本章前面添加的额外 20 GB gp2 卷。

此时，您实际上可以通过单击**启动**按钮来测试您的 AMI，这将启动 EC2 实例向导。点击**查看并启动**按钮后，点击**编辑安全组**链接，通过 SSH 向实例授予您的 IP 地址访问权限，如下图所示:

![](img/c0fd0ffb-bc0b-4026-b9c0-9d8232b143cd.png)

Launching a new EC2 instance

完成后，点击**查看并启动**，然后点击**启动**按钮，最后配置一个您有权访问的合适的 SSH 密钥对。

在启动实例屏幕上，您现在可以单击指向新 EC2 实例的链接，并复制公共 IP 地址，以便可以 SSH 到该实例，如下图所示:

![](img/99e70e6b-1183-437c-bf3b-7d2c04fde547.png)

Connecting to a new EC2 instance

连接到实例后，您可以验证为 Docker 卷存储配置的额外 20 GB 卷是否已成功装载:

```
> sudo mount
proc on /proc type proc (rw,relatime)
sysfs on /sys type sysfs (rw,relatime)
/dev/xvda1 on / type ext4 (rw,noatime,data=ordered)
devtmpfs on /dev type devtmpfs (rw,relatime,size=500292k,nr_inodes=125073,mode=755)
devpts on /dev/pts type devpts (rw,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /dev/shm type tmpfs (rw,relatime)
/dev/xvdcy on /data type ext4 (rw,noatime,data=ordered)
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,relatime)
```

Verifying storage mounts

您可以通过运行`date`命令来检查时区配置是否正确，该命令应显示正确的时区(美国/东方)，并验证`ntpd`服务是否正在运行:

```
> date
Wed Feb 21 06:45:40 EST 2018
> sudo service ntpd status
ntpd is running
```

Verifying time settings

接下来，您可以通过查看`/etc/cloud/cloud.cfg`文件来验证 cloud-init 配置是否已配置为禁用安全更新:

```
> cat /etc/cloud/cloud.cfg
# WARNING: Modifications to this file may be overridden by files in
# /etc/cloud/cloud.cfg.d

# If this is set, 'root' will not be able to ssh in and they
# will get a message to login instead as the default user (ec2-user)
disable_root: true

# This will cause the set+update hostname module to not operate (if true)
preserve_hostname: true

datasource_list: [ Ec2, None ]

repo_upgrade: none
repo_upgrade_exclude:
 - kernel
 - nvidia*
 - cudatoolkit

mounts:
 - [ ephemeral0, /media/ephemeral0 ]
 - [ swap, none, swap, sw, "0", "0" ]
# vim:syntax=yaml
repo_update: false
```

Verifying cloud-init settings

您还应该根据您配置的清理脚本，验证 Docker 服务是否已停止并在启动时被禁用:

```
> sudo service docker status
docker is stopped
> sudo chkconfig --list docker
docker 0:off 1:off 2:off 3:off 4:off 5:off 6:off
```

Verifying disabled services

最后，您可以验证第一次运行的脚本存在于`ec2-user`主目录中:

```
> pwd
/home/ec2-user
> ls 
firstrun.sh
```

Verifying first-run script

此时，您已经成功地验证了您的 ECS 容器实例已经按照您的定制进行了构建，现在您应该从 EC2 控制台终止该实例。您会注意到它处于未配置状态，在 Docker 服务被禁用的情况下，您的 ECS 容器实例实际上不能做太多事情，在下一章中，您将学习如何使用 cloud information 来利用您安装到自定义机器映像中的 cloud information 帮助器脚本来配置实例创建时的 ECS 容器实例，并利用您创建的自定义。

# 摘要

在本章中，您学习了如何使用流行的开源工具 Packer 构建自定义的 ECS 容器实例机器映像。您学习了如何创建 Packer 模板，并了解了组成模板的各个部分，包括变量、构建器、资源调配器和后处理器。作为映像构建过程的一部分，您可以使用 Packer 变量、环境变量和少量 Make automation 的组合来注入验证对 AWS 的访问所需的临时会话凭据。

您成功地在您的 ECS 容器实例映像中引入了许多构建时定制，包括安装 CloudFormation 帮助器脚本和 CloudWatch 日志代理，并确保系统配置为在启动时以正确的时区运行 NTP 服务。您在 cloud-init 配置中禁用了自动安全更新，如果使用 HTTP 代理，这可能会导致问题。

最后，您创建了一个第一次运行的脚本，用于在实例创建和首次引导时配置您的 ECS 容器实例。此脚本配置 ECS 集群成员身份，启用可选的 HTTP 代理支持，为 Docker 和 ECS 代理系统日志配置 CloudWatch 日志代理，并执行运行状况检查以确保您的实例已成功初始化。

在下一章中，您将学习如何使用您的自定义 AMI 来构建 ECS 集群和相关的底层 EC2 自动缩放组，这将有助于您理解对您的自定义机器映像执行各种自定义的基本原理。

# 问题

1.  Packer 模板的哪个部分定义了 Packer 构建过程中使用的临时实例的 EC2 实例类型？
2.  对/错:打包器需要 SSH 在打包器构建过程中访问临时实例。
3.  您使用什么配置文件格式来定义 Packer 模板？
4.  对/错:您必须将您的 AWS 凭证硬编码到您的打包模板中。
5.  对/错:要捕获打包器创建的 AMI ID，您必须解析打包器构建过程的日志输出。
6.  ECS 优化的 AMI 的默认存储配置是什么？
7.  您会使用哪种类型的打包程序将文件写入/etc 目录？
8.  您可以从需要很长时间才能启动的自定义 AMI 创建一个 EC2 实例。AMI 安装在专用子网中，环境中没有配置额外的基础架构。启动时间慢的可能原因是什么？

# 进一步阅读

有关本章所涵盖主题的更多信息，您可以查看以下链接:

*   打包亚马逊 EBS Builder 文档:[https://www.packer.io/docs/builders/amazon-ebs.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html)，[https://docs . AWS . Amazon . com/Amazon ECS/latest/developer guide/welcome . html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html)
*   Amazon ECS-优化 AMI:[https://docs . AWS . Amazon . com/Amazon ECS/latest/developer guide/ECS-优化 _AMI.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html)
*   CloudWatch 日志入门:[https://docs . AWS . Amazon . com/Amazon CloudWatch/latest/logs/CWL _ getting Started . html](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_GettingStarted.html)
*   CloudFormation Helper Scripts 参考:[https://docs . AWS . Amazon . com/AWS cloud information/latest/user guide/cfn-Helper-Scripts-Reference . html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-helper-scripts-reference.html)
*   使用 ECS 命令行界面:[https://docs . AWS . Amazon . com/Amazon ECS/latest/developer guide/ECS _ CLI . html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_CLI.html)