# *第十三章*:向库本内特斯 CVEs 学习

**常见漏洞和暴露** ( **CVEs** )是在流行应用程序中发现的已知安全漏洞和暴露的标识。CVE 标识由`CVE`字符串后跟年份和漏洞的标识号组成。CVE 数据库是公开的，由劳工部公司维护。CVE 条目包括每个问题的简要描述，这有助于理解问题的根本原因和严重性。这些条目不包括有关该问题的技术细节。CVE 对于 IT 专业人员协调和优先更新非常有用。每个 CVE 都有与之相关的严重程度。MITRE 使用一个**通用漏洞评分系统** ( **CVSS** )为 CVE 指定一个严重性等级。建议立即修补高严重性的心血管疾病。让我们看一个 CVE 条目在 cve.mitre.org 的例子。

正如您在下面的截图中看到的，CVE 条目包括 ID、简要描述、参考文献、 **CVE 编号机构** ( **CNA** )的名称以及条目创建的日期:

![Figure 13.1 – MITRE entry for CVE-2018-18264 ](image/B15566_13_001.jpg)

图 13.1-CVE 的 MITRE 条目-2018-18264

对于安全研究人员和攻击者来说，CVE 条目中最有趣的部分是**参考**部分。简历的参考资料是研究人员发表的博客的链接，包括问题的技术细节，以及问题描述和拉取请求的链接。安全研究人员研究参考资料，以了解漏洞，并为类似问题或尚未修复的已知问题开发缓解措施。另一方面，攻击者研究参考文献来发现问题的未修补变体。

在本章中，我们将讨论 Kubernetes 的四个公开的安全漏洞。首先，我们来看一个路径遍历问题——CVE-2019-11246。此问题允许攻击者在客户端修改内容，这可能会导致在群集管理员的机器上执行 exfilter 或代码。接下来，我们将讨论 CVE-2019-1002100，它允许用户对 API 服务器造成**拒绝服务** ( **DoS** )攻击。然后，我们将讨论 CVE-2019-11253，它允许未经身份验证的用户对`kube-apiserver`造成 DoS 攻击。最后，我们将讨论 CVE-2019-11247，它允许具有命名空间权限的用户修改集群范围的资源。我们将讨论每个 CVE 的缓解策略。升级到最新版本的 Kubernetes 和`kubectl`，修补漏洞，应该是你的首要任务。最新的稳定版 Kubernetes 可以在[https://github.com/kubernetes/kubernetes/releases](https://github.com/kubernetes/kubernetes/releases)找到。我们将讨论的缓解策略将有助于增强您的集群抵御类似性质的攻击。最后，我们将介绍`kube-hunter`，它可以用来扫描 Kubernetes 集群中已知的安全漏洞。

我们将在本章中讨论以下主题:

*   库比特 CP-CVE-2019-11246 中的路径遍历问题
*   JSON 解析中的拒绝服务问题——CVE-2019-1002100
*   YAML 句法分析中的拒绝服务问题——CVE-2019-11253
*   角色解析中的权限升级问题——CVE-2019-11247
*   使用 kube-hunter 扫描已知漏洞

# 库贝克特尔 CP-CVE-2019-11246 中的路径遍历问题

开发人员经常将文件复制到 Pod 中的容器或从其中复制文件，以进行调试。`kubectl cp`允许开发人员将文件从 Pod 中的一个容器复制到另一个容器中(默认情况下，这是在 Pod 中的第一个容器中完成的)。

要将文件复制到 Pod，可以使用以下方法:

```
kubectl cp /tmp/test <pod>:/tmp/bar
```

要从 Pod 复制文件，可以使用以下方法:

```
kubectl cp <some-pod>:/tmp/foo /tmp/bar
```

当从 pod 复制文件时，Kubernetes 首先创建容器内文件的 TAR 存档。然后，它将 TAR 归档文件复制到客户端，最后为客户端解压缩 TAR 归档文件。2018 年，研究人员找到了一种使用`kubectl cp`覆盖客户端主机上文件的方法。如果攻击者能够访问 pod，此漏洞可用于通过用恶意的 TAR 二进制文件覆盖原始 TAR 二进制文件，用使用相对路径的特殊文件替换 TAR 归档文件。当格式错误的 TAR 文件复制到主机时，它可能会在提取时覆盖主机上的文件。这可能会导致数据泄露和主机上的代码执行。

让我们看一个例子，攻击者修改 TAR 归档文件，使其具有两个文件:`regular.txt`和`foo/../../../../bin/ps`。在该档案中，`regular.txt`是用户期望的文件，`ps`是恶意二进制文件。如果该档案被复制到`/home/user/admin`，恶意二进制文件会覆盖`bin`文件夹中众所周知的`ps`二进制文件。针对此问题的第一个修补程序不完整，攻击者找到了一种使用符号链接利用相同问题的方法。研究人员找到了一种绕过符号链接修复的方法，最终在版本 1.12.9、1.13.6 和 1.14.2 中得到解决，并被分配给 CVE-2019-112 46。

## 缓解策略

您可以使用以下策略来针对此问题和类似于 CVE-2019-11246 的尚未发现的问题强化您的集群:

*   **始终使用 kubectl 的更新版本**:使用以下命令可以找到最新版本的`kubectl`二进制文件:

    ```
    $ curl https://storage.googleapis.com/kubernetes-release/release/stable.txt
    v1.18.3
    ```

*   **Use admission controllers to limit the use of kubectl cp**: As we discussed in [*Chapter 7*](07.html#_idTextAnchor186), *Authentication, Authorization, and Admission Control*, Open Policy Agent can be used as an admission controller. Let's look at a policy that denies calls to `kubectl cp`:

    ```
    deny[reason] {
      input.request.kind.kind == "PodExecOptions"
      input.request.resource.resource == "pods"
      input.request.subResource == "exec"
      input.request.object.command[0] == "tar"
      reason = sprintf("kubectl cp was detected on %v/%v by user: %v", [
        input.request.namespace,
        input.request.object.container,
        input.request.userInfo.username])
    }
    ```

    该策略拒绝在 pod 中执行 TAR 二进制文件，从而禁用所有用户的`kubectl cp`。您可以更新此策略以允许特定用户或组使用`kubectl cp`。

*   **对客户端应用适当的访问控制**:如果你是生产集群的管理员，你的工作机器上有很多秘密，攻击者可能想要访问。理想情况下，构建机器不应该是您的工作笔记本电脑。拥有管理员可以进入的专用硬件来访问 Kubernetes 集群是一个很好的实践。您还应该确保生成计算机上的任何敏感数据都有适当的访问控制。
*   **为所有 pods** 设置安全上下文:如第 8 章[](08.html#_idTextAnchor249)**中所述，保护 Kubernetes pods* ，确保 Pods 具有`readOnlyRootFilesystem`，这将防止文件被文件系统

    ```
    spec:
        securityContext:
            readOnlyRootFilesystem: true
    ```

    中的攻击者篡改(例如覆盖`/bin/tar binary`)*
**   **Use Falco rules to detect file modification**: We discussed Falco in [*Chapter 11*](11.html#_idTextAnchor324), *Defense in Depth*. Falco rules (which can be found at [https://github.com/falcosecurity/falco/blob/master/rules/falco_rules.yaml](https://github.com/falcosecurity/falco/blob/master/rules/falco_rules.yaml)) can be set up to do the following:

    **检测 pod 中二进制文件的修改**:使用默认的 Falco 规则中的`Write below monitored dir`检测 TAR 二进制文件的更改:

    ```
    - rule: Write below monitored dir
      desc: an attempt to write to any file below a set of binary directories
      condition: >
        evt.dir = < and open_write and monitored_dir
        and not package_mgmt_procs
        and not coreos_write_ssh_dir
        and not exe_running_docker_save
        and not python_running_get_pip
        and not python_running_ms_oms
        and not google_accounts_daemon_writing_ssh
        and not cloud_init_writing_ssh
        and not user_known_write_monitored_dir_conditions
      output: >
        File below a monitored directory opened for writing (user=%user.name
        command=%proc.cmdline file=%fd.name parent=%proc.pname pcmdline=%proc.pcmdline gparent=%proc.aname[2] container_id=%container.id image=%container.image.repository)
      priority: ERROR
      tags: [filesystem, mitre_persistence]
    ```

    **检测到使用了易受攻击的 kubectl 实例**:`kubectl`1 . 12 . 9、1.13.6 和 1.14.2 版对此问题进行了修复。使用早于此的任何版本将触发以下规则:

    ```
    - macro: safe_kubectl_version
      condition: (jevt.value[/userAgent] startswith "kubectl/v1.15" or
                  jevt.value[/userAgent] startswith "kubectl/v1.14.3" or
                  jevt.value[/userAgent] startswith "kubectl/v1.14.2" or
                  jevt.value[/userAgent] startswith "kubectl/v1.13.7" or
                  jevt.value[/userAgent] startswith "kubectl/v1.13.6" or
                  jevt.value[/userAgent] startswith "kubectl/v1.12.9")
    # CVE-2019-1002101
    # Run kubectl version --client and if it does not say client version 1.12.9,
    1.13.6, or 1.14.2 or newer,  you are running a vulnerable version.
    - rule: K8s Vulnerable Kubectl Copy
      desc: Detect any attempt vulnerable kubectl copy in pod
      condition: kevt_started and pod_subresource and kcreate and
                 ka.target.subresource = "exec" and ka.uri.param[command] = "tar" and
                 not safe_kubectl_version
      output: Vulnerable kubectl copy detected (user=%ka.user.name pod=%ka.target.name ns=%ka.target.namespace action=%ka.target.subresource command=%ka.uri.param[command] userAgent=%jevt.value[/userAgent])
      priority: WARNING
      source: k8s_audit
      tags: [k8s]
    ```* 

 *CVE-2019-11246 是一个很好的例子，说明了为什么您需要跟踪安全咨询并通读技术细节，以向您的集群添加缓解策略，从而确保如果发现问题的任何变体，您的集群是安全的。接下来我们来看看 CVE-2019-1002100，可以用来在`kube-apiserver`上引起 DoS 问题。

# JSO 的拒绝服务问题 N 解析-CVE-2019-1002100

修补是一种常用的技术，用于在运行时更新 API 对象。开发人员使用`kubectl patch`在运行时更新 API 对象。一个简单的例子是给一个吊舱添加一个容器:

```
spec:
  template:
    spec:
      containers:
      - name: db
        image: redis
```

前面的补丁文件允许一个 pod 被更新为一个新的 Redis 容器。`kubectl patch`允许补丁采用 JSON 格式。问题出在`kube-apiserver`的 JSON 解析代码中，这使得攻击者能够发送格式错误的`json-patch`实例，从而在 API 服务器中造成 DoS 攻击。在 [*第 10 章*](10.html#_idTextAnchor305)*实时监控和资源管理 Kubernetes 集群*中，我们讨论了 Kubernetes 集群内服务可用性的重要性。这个问题的根本原因是未检查的错误条件和对`patch`请求的`kube-apiserver`的无限内存分配。

## 缓解策略

您可以使用以下策略针对此问题和类似于 CVE-2019-100210 的尚未发现的问题强化您的集群:

*   **Use resource monitoring tools in Kubernetes clusters**: As discussed in [*Chapter 10*](10.html#_idTextAnchor305), *Real-Time Monitoring and Resource Management of a Kubernetes Cluster*, resource-monitoring tools such as Prometheus and Grafana can help identify issues of higher memory consumption in the master node. High values in the graphs for Prometheus metrics could look as follows:

    ```
    container_memory_max_usage_bytes{pod_ name="kube-apiserver-xxx" }
    sum(rate(container_cpu_usage_seconds_total{pod_name="kube-apiserver-xxx"}[5m]))
    sum(rate(container_network_receive_bytes_total{pod_name="kube-apiserver-xxx"}[5m]))
    ```

    这些资源以`kube-apiserver`为单位，每隔 5 分钟显示最大内存、中央处理器和网络使用率。这些使用模式中的任何异常都是攻击`kube-apiserver`的信号。

*   **Set up high-availability Kubernetes masters**: We learned about high-availability clusters in [*Chapter 11*](11.html#_idTextAnchor324), *Defense in Depth*. High-availability clusters have multiple instances of Kubernetes components. If the load on one component is high, other instances can be used until the load is reduced or the first instance is restarted.

    使用`kops`，可以使用`--master-zones={zone1, zone2}`拥有多个主控:

    ```
    kops create cluster k8s-clusters.k8s-demo-zone.com \
     --cloud aws \
     --node-count 3 \
     --zones $ZONES \
     --node-size $NODE_SIZE \
     --master-size $MASTER_SIZE \
     --master-zones $ZONES \
     --networking calico \
     --kubernetes-version 1.14.3 \
     --yes \
    kube-apiserver-ip-172-20-43-65.ec2.internal              1/1     Running   4          4h16m
    kube-apiserver-ip-172-20-67-151.ec2.internal             1/1     Running   4          4h15m
    ```

    可以看到，这个集群中运行着多个`kube-apiserver`吊舱。

*   **限制用户使用 RBAC** 的权限:用户的权限也要遵循最小权限原则，在 [*第 4 章*](04.html#_idTextAnchor108)*中讨论了在 Kubernetes* 中应用最小权限原则。如果用户不需要任何资源的`PATCH`访问权限，则应该更新角色，使他们没有访问权限。
*   **在分段环境**中测试您的补丁程序:分段环境应该设置为生产环境的副本。开发人员并不完美，因此开发人员可能会创建一个格式错误的补丁。如果在临时环境中测试集群的补丁或更新，则可以在不中断生产服务的情况下找到补丁中的错误。

DoS 通常被认为是一个低严重性的问题，但是如果它发生在您的集群的核心组件上，您应该认真对待它。`kube-apiserver`上的 DoS 攻击会破坏整个集群的可用性。接下来，我们看另一个针对 API 服务器的 DoS 攻击。未经身份验证的用户可以执行此攻击，这使得它比 CVE-2019-1002100 更加严重。

# YAML 解析中的拒绝服务问题——CVE-2019-11253

XML 炸弹，或者说十亿次“T4”攻击，在任何 XML 解析代码中都很流行。类似于 XML 中的解析问题，这是发送到`kube-apiserver`的 YAML 文件中的解析问题。如果发送到服务器的 YAML 文件有递归引用，它会触发`kube-apiserver`消耗 CPU 资源，从而导致应用编程接口服务器的可用性问题。在大多数情况下，`kube-apiserver`解析的请求仅限于经过身份验证的用户，因此未经身份验证的用户不应触发此问题。在 1.14 之前的 Kubernetes 版本中，该规则有一个例外，允许未经身份验证的用户检查他们是否可以使用`kubectl auth can-i`执行操作。

此问题与 CVE-2019-1002100 相似，但更严重，因为未经身份验证的用户也可以触发此问题。

## 缓解策略

您可以使用以下策略针对此问题和类似于 CVE-2019-11253 的尚未发现的问题强化您的集群:

*   **在 Kubernetes 集群**中使用资源监控工具:与 CVE-2019-1002100 类似，我们在 [*第 10 章*](10.html#_idTextAnchor305)*中讨论的 Prometheus 和 Grafana 等资源监控工具可以帮助识别 Kubernetes 集群*中内存消耗较高的问题。
*   **启用 RBAC** :该漏洞是由于`kube-apiserver`对 YAML 文件中递归实体的处理不当以及未经身份验证的用户与`kube-apiserver`交互的能力造成的。我们在第 7 章[](07.html#_idTextAnchor186)**认证、授权和准入控制*中讨论了 RBAC。在当前版本的 Kubernetes 中，默认情况下启用 RBAC。您也可以通过将`--authorization-mode=RBAC`传递到`kube-apiserver`来启用它。在这种情况下，未经认证的用户不得与`kube-apiserver`互动。对于经过身份验证的用户，应遵循最小特权原则。*
**   **Disable auth can-i for unauthenticated users (for v1.14.x)**: Unauthenticated users should not be allowed to interact with `kube-apiserver`. In Kubernetes v1.14.x, you can disable `auth can-i` for unauthenticated servers using the RBAC file at [https://github.com/kubernetes/kubernetes/files/3735508/rbac.yaml.txt](https://github.com/kubernetes/kubernetes/files/3735508/rbac.yaml.txt):

    ```
    kubectl auth reconcile -f rbac.yaml --remove-extra-subjects --remove-extra-permissions
    kubectl annotate --overwrite clusterrolebinding/system:basic-user rbac.authorization.kubernetes.io/autoupdate=false 
    ```

    第二个命令禁用`clusterrolebinding`的自动更新，这将确保重启时更改不会被覆盖。

    *   **kube-apiserver 不应暴露于互联网**:允许可信实体使用防火墙或 VPCs 访问 API 服务器是一个很好的做法。*   **禁用匿名授权**:我们在 [*第 6 章*](06.html#_idTextAnchor170)*保护集群组件*中讨论了`anonymous-auth`作为一个应该禁用的选项。默认情况下，在 Kubernetes 1.16+中，对旧策略规则启用匿名身份验证。如果您没有使用任何遗留规则，建议通过默认将`--anonymous-auth=false`传递给应用编程接口服务器来禁用`anonymous-auth`。*

 *正如我们前面讨论的，对`kube-apiserver`的 DoS 攻击会导致整个集群的服务中断。除了使用最新版本的 Kubernetes(包括针对此问题的修补程序)之外，遵循这些缓解策略以避免集群中出现类似问题也很重要。接下来，我们将讨论授权模块中的一个问题，该问题会触发经过身份验证的用户的权限提升。

# 角色解析中的权限升级问题–CVE-2019-11247

我们在第 7 章*认证、授权和准入控制*中详细讨论了 RBAC。角色和角色绑定允许用户获得执行特定操作的权限。这些特权是命名空间。如果用户需要集群范围的权限，则使用集群角色和集群角色绑定。此问题允许用户进行群集范围的修改，即使他们的权限是命名空间的。接纳控制器的配置，如开放策略访问，可以由具有命名空间角色的用户修改。

## 缓解策略

您可以使用以下策略来针对此问题和类似于 CVE-2019-11247 的尚未发现的问题强化您的集群:

*   **避免在角色和角色绑定**中使用通配符:角色和集群角色应该特定于资源名称、动词和应用编程接口组。将`*`添加到`roles`可以允许用户访问他们不应该访问的资源。这坚持了我们在 [*第四章*](04.html#_idTextAnchor108)*中讨论的最小特权原则，在库本内斯*中应用最小特权原则。
*   **Enable Kubernetes auditing**: We discussed auditing and audit policies for Kubernetes in [*Chapter 11*](11.html#_idTextAnchor324), *Defense in Depth*. Kubernetes auditing can help identify any unintended actions in a Kubernetes cluster. In most cases, a vulnerability such as this will be used to modify and delete any additional controls within the cluster. You can use the following policy to identify instances of these kinds of exploits:

    ```
      apiVersion: audit.k8s.io/v1 # This is required.
          kind: Policy
          rules:
          - level: RequestResponse
            verbs: ["patch", "update", "delete"]
            resources:
            - group: ""
              resources: ["pods"]
              namespaces: ["kube-system", "monitoring"]
    ```

    此策略记录在`kube-system`或`monitoring`命名空间中删除或修改 pods 的任何实例。

这个问题当然是一个有趣的问题，因为它强调了 Kubernetes 提供的安全功能如果配置错误也是有害的。接下来，我们将讨论`kube-hunter`，这是一个开源工具，可以在您的集群中找到任何已知的安全问题。

# 使用 kube-hunter 扫描已知漏洞

由 kubernetes 发布的安全建议和公告([https://Kubernetes . io/docs/reference/issues-security/security/](https://kubernetes.io/docs/reference/issues-security/security/))是跟踪 Kubernetes 中发现的新安全漏洞的最佳方式。公告和咨询电子邮件可能会让人有点不知所措，而且总是有可能错过一个重要的漏洞。为了避免这些情况，一个定期检查集群中任何已知 CVE 的工具来拯救。`kube-hunter`是由 Aqua 开发和维护的开源工具，有助于识别您的 Kubernetes 集群中已知的安全问题。

设置`kube-hunter`的步骤如下:

1.  克隆存储库:

    ```
    $git clone https://github.com/aquasecurity/kube-hunter
    ```

2.  运行集群中的`kube-hunter`吊舱:

    ```
    $ ./kubectl create -f job.yaml
    ```

3.  View the logs to find any issues with your cluster:

    ```
    $ ./kubectl get pods
    NAME                READY   STATUS              RESTARTS   AGE
    kube-hunter-7hsfc   0/1     ContainerCreating   0          12s
    ```

    以下输出显示了 Kubernetes v1.13.0 中已知漏洞的列表:

![Figure 13.2 – Results of kube-hunter ](image/B15566_13_002.jpg)

图 13.2–库贝-亨特的结果

这个截图强调了`kube-hunter`为 Kubernetes v1.13.0 集群发现的一些问题。`kube-hunter`发现的问题应被视为关键问题，并应立即解决。

# 摘要

在这一章中，我们讨论了客户价值评估的重要性。这些公开的标识符对于集群管理员、安全研究人员和攻击者来说非常重要。我们讨论了由 MITRE 维护的 CVE 条目的重要方面。然后，我们查看了四个著名的 CVE，并讨论了每个 CVE 的问题和缓解策略。作为集群管理员，升级`kubectl`客户端和 Kubernetes 版本应该永远是您的第一要务。但是，添加缓解策略来检测和防止由未公开报告的类似问题引起的漏洞同样重要。最后，我们讨论了一个开源工具`kube-hunter`，它可以用来定期识别您的 Kubernetes 集群中的问题。这消除了集群管理员密切关注 Kubernetes 的安全建议和公告的开销。

现在，您应该能够理解公开披露的漏洞的重要性，以及这些建议如何帮助加强您的 Kubernetes 集群的整体安全态势。通读这些建议将有助于您识别集群中的任何问题，并有助于进一步强化集群。

# 问题

1.  对于集群管理员、安全研究人员和攻击者来说，CVE 条目最重要的部分是什么？
2.  为什么像 CVE-2019-11246 这样的客户端安全问题对 Kubernetes 集群很重要？
3.  为什么 kube-apiserver 中的 DoS 问题被视为高严重性问题？
4.  比较 API 服务器中经过身份验证和未经身份验证的 DoS 问题。
5.  讨论`kube-hunter`的重要性。

# 更多参考

*   《CVE 清单》:https://CVE . mitre . org/CVE/search _ CVE _ list . html
*   用 Falco 检测 CVE-2019-11246:[https://sysdig . com/blog/how-detect-kubernetes-漏洞-CVE-2019-11246-使用-falco/](https://sysdig.com/blog/how-to-detect-kubernetes-vulnerability-cve-2019-11246-using-falco/)
*   用 OPA 预防 CVE-2019-11246:[https://blog . styra . com/blog/investing-and-correct-cves-with-k8s-API](https://blog.styra.com/blog/investigate-and-correct-cves-with-the-k8s-api)
*   CVE-2019-1002100 的 GitHub 问题:t1]
*   CVE-2019-11253 的 GitHub 问题:t1]
*   CVE-2019-11247 的 GitHub 问题:t1]
*   `kube-hunter`:[https://github . com/aqua security/kube-hunter](https://github.com/aquasecurity/kube-hunter)
*   CVE 2020-8555 的 GitHub 问题:t1]
*   CVE 2020-8555 的 GitHub 问题:[https://github . com/kubrines/kubrines/issues/91507](https://github.com/kubernetes/kubernetes/issues/91507)**