# *第四章*:在库伯内斯运用最小特权原则

最低特权原则规定，生态系统的每个组成部分都应该有最低限度的数据和资源访问权限，才能正常运行。在多租户环境中，不同的用户或对象可以访问多个资源。最小特权原则确保了如果用户或对象在这种环境中行为不检，对集群的损害最小。

在本章中，我们将首先介绍最小特权原则。鉴于 Kubernetes 的复杂性，我们将首先研究 Kubernetes 主题，然后研究主题可用的特权。然后，我们将讨论 Kubernetes 对象的特权以及限制它们的可能方法。本章的目标是帮助您理解几个关键概念，例如最小特权原则和**基于角色的访问控制** ( **RBAC** )。在本章中，我们将讨论不同的 Kubernetes 对象，例如名称空间、服务帐户、角色和角色绑定，以及 Kubernetes 安全特性，例如安全上下文、PodSecurityPolicy 和 NetworkPolicy，它们可以用来实现 Kubernetes 集群的最小特权原则。

在本章中，我们将涵盖以下主题:

*   最小特权原则
*   库本内特臣民的最低特权
*   Kubernetes 工作负载的最低特权

# 最小特权原则

特权是执行某项操作的权限，如访问资源或处理某些数据。最小特权原则是指任何主体、用户、程序、进程等都应该只有执行其功能所需的最小特权。例如，爱丽丝，一个普通的 Linux 用户，能够在自己的主目录下创建一个文件。换句话说，Alice 至少有权限在自己的主目录下创建一个文件。但是，Alice 可能无法在另一个用户的目录下创建文件，因为她没有这样做的权限。如果 Alice 的日常任务实际上都没有在主目录中创建文件的权限，但是她确实有这样做的权限，那么机器的管理员就没有遵守最小权限原则。在本节中，我们将首先介绍授权模型的概念，最小特权的概念就是从该模型中衍生出来的，然后，我们将讨论实施最小特权原则的好处。

## 授权模型

当我们谈论最少特权的时候，大部分时间都是在授权的语境下谈论，在不同的环境下，会有不同的授权模型。以为例，**访问控制列表** ( **ACL** )被广泛用于 Linux 和网络防火墙，而 RBAC 则被用于数据库系统。环境管理员还需要定义授权策略，以确保基于系统中可用授权模型的最低权限。下面的列表定义了一些流行的授权模型:

*   **ACL**:ACL 定义了与对象相关联的权限列表。它规定了哪些主体被授予对对象的访问权限，以及在给定对象上允许哪些操作。例如，`-rw`文件权限是文件所有者的只读-写权限。
*   **RBAC** :授权决定基于主体的角色，其中包含一组权限或特权。例如，在 Linux 中，用户被添加到不同的组(如`staff`)中，以授予对某些文件夹的访问权限，而不是单独授予对文件系统上文件夹的访问权限。
*   **基于属性的访问控制(ABAC)** :授权决定基于主体的属性，例如标签或属性。基于属性的规则检查用户属性，如`user.id="12345"`、`user.project="project"`和`user.status="active"`，以决定用户是否能够执行任务。

库本内斯支持 ABAC 和 RBAC。虽然 ABAC 功能强大且灵活，但是在 Kubernetes 中的实现使得它很难管理和理解。因此，建议在库本内斯启用 RBAC，而不是 ABAC。除了 RBAC，Kubernetes 还提供了多种限制资源访问的方法。在接下来的章节中，在我们研究库本内斯的 RBAC 和 ABAC 之前，让我们讨论一下确保最低特权的好处。

## 最低特权原则的奖励

虽然理解受试者执行其功能的最低权限可能需要相当长的时间，但如果在您的环境中实施了最低权限原则，则回报也是显著的:

*   **更好的安全性**:内部威胁、恶意软件传播、横向移动等都可以通过实施最小特权原则来缓解。爱德华·斯诺登的泄密是因为缺乏最起码的特权。
*   **更好的稳定性**:鉴于的臣民只被适当地授予必要的特权，臣民的活动变得更加可预测。作为回报，系统的稳定性得到了加强。
*   **提高审核准备度**:如果只适当授予主体必要的权限，审核范围将大幅缩小。此外，许多共同法规要求实施最低特权原则作为合规要求。

既然您已经看到了实现最小特权原则的好处，我也想介绍一下挑战:Kubernetes 的开放性和可配置性使得实现最小特权原则变得很麻烦。让我们来看看如何将最小特权原则应用于 Kubernets 科目。

# 库本内特人的最低特权

Kubernetes 服务帐户、用户和组与`kube-apiserver`通信以管理 Kubernetes 对象。启用 RBAC 后，不同的用户或服务帐户可能拥有不同的权限来操作 Kubernetes 对象。例如，`system:master`组中的用户被授予了`cluster-admin`角色，这意味着他们可以管理整个 Kubernetes 集群，而`system:kube-proxy`组中的用户只能访问`kube-proxy`组件所需的资源。首先，让我们简单谈谈 RBAC 是什么。

## RBAC 简介

如前所述，RBAC 是一个基于授予用户或组的角色来管理资源访问的模型。从 1.6 版本开始，默认情况下在 Kubernetes 中启用 RBAC。在 1.6 版本之前，RBAC 可以通过运行带有`--authorization-mode=RBAC`标志的**应用编程接口** ( **应用编程接口**)服务器来启用。RBAC 使用 API 服务器简化了权限策略的动态配置。

RBAC 的核心要素包括以下内容:

1.  **主题**:服务请求访问库本内特斯应用编程接口的帐户、用户或组。
2.  **资源**:库本内斯需要被主体访问的对象。
3.  **动词**:主题需要对资源进行不同的类型的访问，例如，创建、更新、列出、删除。

库本内特·RBAC 定义了库本内特生态系统中的主体和他们对不同资源的访问类型。

## 服务帐户、用户和组

Kubernetes 支持三种类型的主题，如下所示:

*   **常规用户**:这些用户是集群管理员创建的。它们在库本内斯生态系统中没有相应的对象。集群管理员通常使用**轻量级目录访问协议** ( **LDAP** )、**活动目录** ( **AD** )或私钥来创建用户。
*   **服务帐户** : Pods 使用服务帐户向`kube-apiserver`对象进行身份验证。使用应用编程接口调用创建服务帐户。它们仅限于名称空间，并且具有存储为`secrets`的相关凭证。默认情况下，pods 认证为`default`服务帐户。
*   **匿名用户**:任何不与常规或服务帐户相关联的 API 请求都与匿名用户相关联。

群集管理员可以通过运行以下命令来创建与 pods 关联的新服务帐户:

```
$ kubectl create serviceaccount new_account
```

将在默认命名空间中创建一个`new_account`服务帐户。为了确保最低权限，集群管理员应该将每个 Kubernetes 资源与具有最低操作权限的服务帐户相关联。

## 角色

角色是权限的集合——例如，名称空间 A 中的角色可以允许用户在名称空间 A 中创建 pods，并在名称空间 A 中列出秘密。在 Kubernetes 中，没有拒绝权限。因此，角色是一组权限的添加。

角色仅限于命名空间。另一方面，集群角色在集群级别工作。用户可以创建一个跨整个集群的集群角色。集群角色可用于调解对跨集群的资源的访问，如节点、运行状况检查和命名空间对象，如跨多个命名空间的 pods。下面是一个角色定义的简单示例:

```
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: role-1
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get"]
```

这个简单的规则允许`get`操作在默认命名空间中过度使用`pods`。通过执行以下命令，可以使用`kubectl`创建该角色:

```
$ kubectl apply -f role.yaml
```

只有满足以下任一条件，用户才能创建或修改角色:

*   用户在同一范围内(命名空间或集群范围)拥有角色中包含的所有权限。
*   用户与给定范围内的升级角色相关联。

这可以防止用户通过修改用户角色和权限来执行权限提升攻击。

## 卷接

角色绑定对象用于将角色与主题相关联。与集群角色类似，集群角色绑定可以跨名称空间向主体授予一组权限。让我们看几个例子:

1.  创建一个角色绑定对象，将`custom-clusterole`集群角色与默认名称空间中的`demo-sa`服务帐户相关联，如下所示:

    ```
    kubectl create rolebinding new-rolebinding-sa \
         --clusterrole=custom-clusterrole \
         --serviceaccount=default:demo-sa
    ```

2.  创建一个角色绑定对象，将一个`custom-clusterrole`集群角色关联到`group-1`组，如下所示:

    ```
    kubectl create rolebinding new-rolebinding-group \
         --clusterrole=custom-clusterrole \
         --group=group-1 \
         --namespace=namespace-1
    ```

角色绑定对象将角色链接到主题，并使角色可重用且易于管理。

## 非组合命名空间

命名空间是计算机科学中的一个常见概念，它为相关资源提供逻辑分组。名称空间用于避免名称冲突；同一命名空间内的资源应该具有唯一的名称，但是跨命名空间的资源可以共享名称。在 Linux 生态系统中，名称空间允许隔离系统资源。

在 Kubernetes 中，名称空间允许团队和项目之间逻辑地共享一个集群。对于 Kubernetes 命名空间，以下内容适用:

*   它们允许不同的应用程序、团队和用户在同一个集群中工作。
*   它们允许集群管理员为应用程序使用命名空间资源配额。
*   他们使用 RBAC 策略来控制对名称空间中特定资源的访问。角色绑定有助于集群管理员控制授予命名空间内用户的权限。
*   它们允许使用命名空间中定义的网络策略进行网络分段。默认情况下，所有 pods 都可以跨不同的名称空间相互通信。

默认情况下，Kubernetes 有三个不同的名称空间。运行以下命令查看它们:

```
$ kubectl get namespace
NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d
kube-public   Active    1d
```

这三个名称空间描述如下:

*   `default`:不属于任何其他命名空间的资源的命名空间。
*   `kube-system`:库本内特创建的对象的命名空间，如`kube-apiserver`、`kube-scheduler`、`controller-manager`和`coredns`。
*   `kube-public`:这个命名空间内的资源是所有人都可以访问的。默认情况下，不会在此命名空间中创建任何内容。

让我们看看如何创建一个名称空间。

### 创建命名空间

使用以下命令可以在 Kubernetes 中创建新的命名空间:

```
$ kubectl create namespace test
```

一旦创建了新的命名空间，就可以使用`namespace`属性将对象分配给命名空间，如下所示:

```
$ kubectl apply --namespace=test -f pod.yaml
```

命名空间中的对象同样可以通过使用`namespace`属性来访问，如下所示:

```
$ kubectl get pods --namespace=test
```

在 Kubernetes 中，并不是所有的对象都有命名空间。像`Nodes`和`persistentVolumes`这样的低级对象跨越命名空间。

## 总结库本内特人最少的特权

到目前为止，您应该已经熟悉了集群角色/角色、集群角色绑定/角色绑定、服务帐户和名称空间的概念。为了实现 Kubernetes 主体的最低特权，在 Kubernetes 中创建角色或角色绑定对象之前，您可以问自己以下问题:

*   Does the subject need privileges for a namespace or across namespaces?

    这很重要，因为一旦主体拥有集群级别的权限，它就可以跨所有名称空间行使权限。

*   Should the privileges be granted to a user, group, or service account?

    当您将角色授予某个组时，这意味着该组中的所有用户都将自动获得新授予角色的权限。在将角色授予某个组之前，请确保您了解其影响。接下来，Kubernetes 中的一个用户用于人类，而服务帐户用于 pods 中的微服务。确保您知道 Kubernetes 用户的职责是什么，并相应地分配权限。此外，请注意，一些微服务根本不需要任何特权，因为它们不直接与`kube-apiserver`或任何 Kubernetes 对象交互。

*   What are the resources that the subjects need to access?

    创建角色时，如果不指定资源名称或在`resourceNames`字段中设置`*`，则意味着该资源类型的所有资源都被授予访问权限。如果你知道主题将要访问的资源名称，在创建角色时一定要指定资源名称。

Kubernetes 主体使用授予的权限与 Kubernetes 对象进行交互。了解库本内特斯臣民执行的实际任务将有助于你正确授予特权。

# 对 Kubernetes 工作负载的最低特权

通常，会有一个与 Kubernetes 工作负载相关联的服务帐户(默认)。因此，pod 内的进程可以使用服务帐户令牌与`kube-apiserver`通信。出于最低权限的目的，DevOps 应该谨慎地向服务帐户授予必要的权限。我们在上一节已经讨论过了。

除了访问`kube-apiserver`来操作 Kubernetes 对象之外，pod 中的进程还可以访问集群中的工作节点和其他 pod/微服务上的资源(在 [*第 2 章*](02.html#_idTextAnchor049)*Kubernetes Networking*中介绍)。在这一节中，我们将讨论访问系统资源、网络资源和应用程序资源的可能的最低特权实现。

## 访问系统资源的最低权限

回想一下，在容器或 pod 中运行的微服务只不过是工作节点上的一个进程，隔离在它自己的命名空间中。pod 或容器可以根据配置访问工作节点上不同类型的资源。这是由安全上下文控制的，可以在 pod 级别和容器级别进行配置。配置 pod/容器安全上下文应该在开发人员的任务列表中(在安全设计和审查的帮助下)，而 pod 安全策略——在集群级别限制 pod/容器访问系统资源的另一种方法——应该在 DevOps 的待办事项列表中。让我们来看看安全上下文、PodSecurityPolicy 和资源限制控制的概念。

### 安全上下文

安全上下文提供了一种方式来定义关于访问系统资源的吊舱和容器的特权和访问控制设置。在 Kubernetes 中，pod 级别的安全上下文不同于容器级别的安全上下文，尽管两个级别都可以配置一些重叠的属性。一般来说，安全上下文提供了以下功能，允许您对容器和容器应用最小特权原则:

*   **自主访问控制(DAC)** :这里是配置哪个**用户 ID** ( **UID** )或者**组 ID** ( **GID** )绑定到容器中的进程，容器的根文件系统是否为只读等等。强烈建议不要以根用户身份( *UID = 0* )在容器中运行您的微服务。其安全含义是，如果存在漏洞并且容器逃到主机，攻击者会立即获得主机上的根用户权限。
*   **安全增强 Linux (SELinux):** 这是为了配置 SELinux 安全上下文，为 pods 或容器定义级别标签、角色标签、类型标签和用户标签。分配 SELinux 标签后，pod 和容器可能会在访问资源方面受到限制，尤其是节点上的卷。
*   **特权模式:**这是为了配置容器是否在特权模式下运行。在特权容器内部运行的进程的能力与节点上的根用户基本相同。
*   **Linux 功能:**这是为容器配置 Linux 功能。不同的 Linux 功能允许容器内的进程在节点上执行不同的活动或访问不同的资源。例如，`CAP_AUDIT_WRITE`允许进程写入内核审计日志，而`CAP_SYS_ADMIN`允许进程执行一系列管理操作。
*   **apparemor:**这是为了配置吊舱或容器的 apparemor 配置文件。AppArmor 概要文件通常定义进程拥有哪些 Linux 功能，容器可以访问哪些网络资源和文件，等等。
*   **安全计算模式(seccomp):** 这是为吊舱或容器配置 seccomp 配置文件。seccomp 配置文件通常定义允许执行的系统调用的白名单和/或阻止在 pod 或容器内执行的系统调用的黑名单。
*   **允许特权升级:**这是为了配置一个进程是否可以获得比其父进程更多的特权。请注意，当容器以特权运行或具有`CAP_SYS_ADMIN`功能时，`AllowPrivilegeEscalation`始终为真。

我们将在 [*第 8 章*](08.html#_idTextAnchor249)*保护吊舱*中更多地讨论安全上下文。

### 公共安全政策

PodSecurityPolicy 是一个 Kubernetes 集群级资源，它控制 pod 规范中与安全性相关的属性。它定义了一套规则。当要在 Kubernetes 集群中创建 pods 时，pods 需要遵守 PodSecurityPolicy 中定义的规则，否则它们将无法启动。政策控制或应用以下属性:

*   允许运行特权容器
*   允许使用主机级命名空间
*   允许使用主机端口
*   允许使用不同类型的卷
*   允许访问主机的文件系统
*   需要为容器运行只读根文件系统
*   限制容器的用户标识和组标识
*   限制容器的权限升级
*   限制容器的 Linux 功能
*   需要使用 SELinux 安全上下文
*   将 seccomp 和 AppArmor 配置文件应用于吊舱
*   限制 pod 可以运行的系统
*   允许使用`proc`安装类型
*   将 FSGroup 限制为卷

我们将在 [*第 8 章*](08.html#_idTextAnchor249)*中介绍更多关于 PodSecurityPolicy 的内容，以保护 Kubernetes Pods* 。PodSecurityPolicy 控件基本上是作为准入控制器实现的。您也可以创建自己的准入控制器，为您的工作负载应用自己的授权策略。**开放策略代理** ( **OPA** )是针对某个工作负载实现自己的最低特权策略的另一个好人选。我们将在 [*第 7 章*](07.html#_idTextAnchor186)*认证、授权和准入控制*中更多地了解 OPA。

现在，让我们看看 Kubernetes 中的资源限制控制机制，因为您可能不希望您的微服务饱和系统中的所有资源，如**中央处理器** ( **中央处理器**)和内存。

### 资源限制控制

默认情况下，单个容器可以使用与节点一样多的内存和 CPU 资源。运行加密挖掘二进制文件的容器可能会很容易消耗由其他荚共享的节点上的 CPU 资源。为工作负载设置资源请求和限制总是一种好的做法。资源请求会影响调度程序将 pods 分配给哪个节点，而资源限制会设置终止容器的条件。将更多的资源请求和工作负载限制分配给以避免驱逐或终止总是安全的。但是，请记住，如果您将资源请求或限制设置得太高，将会导致集群上的资源浪费，并且分配给工作负载的资源可能不会得到充分利用。我们将在 [*第 10 章*](10.html#_idTextAnchor305) 、*实时监控和库本内特集群的资源管理*中详细介绍这个顶级 ic。

## 总结访问系统资源的最小特权

当 pods 或容器以特权模式运行时，与非特权 pods 或容器不同，它们在节点上具有与管理员用户相同的特权。如果您的工作负载以特权模式运行，为什么会出现这种情况？当 pod 能够评估主机级名称空间时，pod 可以访问主机级的网络堆栈、进程和**进程间通信** ( **IPC** )等资源。但是，您真的需要授予主机级别的名称空间访问权限或者为您的 pods 或容器设置特权模式吗？此外，如果您知道容器中的进程需要哪些 Linux 功能，您最好删除那些不必要的功能。有多少内存和中央处理器足以让您的工作负载充分发挥作用？请仔细考虑这些问题，以便为您的 Kubernetes 工作负载实现最小特权原则。正确设置资源请求和限制，为您的工作负载使用安全上下文，并为您的集群实施 PodSecurityPolicy。所有这些都将帮助 ens 为您的工作负载确保访问系统资源的最低特权。

## 访问网络资源的最低权限

默认情况下，同一 Kubernetes 集群内的任意两个 pod 可以相互通信，如果 Kubernetes 集群外没有配置代理规则或防火墙规则，一个 pod 可能能够与互联网通信。Kubernetes 的开放性模糊了微服务的安全边界，我们不能忽视网络资源，比如容器或 pod 可以访问的其他微服务提供的 API 端点。

假设您在命名空间 X 中的一个工作负载(pod X)只需要访问命名空间 NS1 中的另一个微服务 A；同时，名称空间 NS2 中还有微服务 B。微服务 A 和微服务 B 都公开了它们的**表征状态转移** ( **REST** ful)端点。默认情况下，您的工作负载可以同时访问微服务 A 和 B，假设在微服务级别既没有身份验证也没有授权，并且在名称空间 NS1 和 NS2 中也没有实施网络策略。请看下面的图，说明了这一点:

![Figure 4.1 – Network access without network policy ](image/B15566_04_001.jpg)

图 4.1–无网络策略的网络访问

在上图中， **Pod X** 能够访问两个微服务，尽管它们位于不同的名称空间中。还要注意的是， **Pod X** 只需要访问名称空间 **NS1** 中的**微服务 A** 。那么，我们能做些什么来限制 **Pod X 对**微服务 A** 的**访问，仅仅是出于最低特权的目的吗？是的:Kubernetes 网络政策会有所帮助。我们将更详细地介绍网络策略 [*第 5 章*](05.html#_idTextAnchor144)*配置 Kubernetes 安全边界*。一般来说，Kubernetes 网络策略定义了允许一组 pods 相互通信以及与其他网络端点通信的规则。您可以为工作负载定义入口规则和出口规则。

注意

入口规则:定义在网络策略的保护下允许哪些源与吊舱通信的规则。

出口规则:定义在网络策略的保护下允许哪些目的地与吊舱通信的规则。

在下面的例子中，为了在 **Pod X** 中实现最小特权的原则，您将需要在**命名空间 X** 中定义一个网络策略，该策略带有一个出口规则，指定只允许**微服务 A** :

![Figure 4.2 – Network policy blocks access to microservice B ](image/B15566_04_002.jpg)

图 4.2–网络策略阻止对微服务 B 的访问

在上图中，**命名空间 X** 中的网络策略阻止了从 **Pod X** 到**微服务 B** 的任何请求， **Pod X** 仍然可以访问**微服务 A** ，这是意料之中的。在您的网络策略中定义出口规则将有助于确保您的工作负载访问网络资源的最低权限。最后但同样重要的是，我们仍然需要从最低特权的角度将您的 at 关注提升到应用程序资源级别。

## 访问应用程序资源的最低权限

虽然这个话题属于应用安全的范畴，但这里值得一提。如果您的工作负载访问的应用程序支持具有不同权限级别的多个用户，最好检查代表您的工作负载授予用户的权限是否必要。例如，负责审核的用户不需要任何写权限。应用程序开发人员在设计应用程序时应该记住这一点。这有助于确保您的工作负载以最少的权限访问应用程序资源。

# 总结

在这一章中，我们讨论了最小特权的概念。然后，我们讨论了 Kubernetes 中的安全控制机制，它有助于在两个方面实现最小特权原则:Kubernetes 主题和 Kubernetes 工作负载。值得强调的是，从整体上落实最小特权原则的重要性。如果在任何区域错过了最小特权，这将有可能使攻击面大开。

Kubernetes 提供内置的安全控制来实现最小特权原则。请注意，这是一个从开发到部署的过程:应用程序开发人员应该与安全架构师合作，为与应用程序相关联的服务帐户设计最低权限，以及最低功能和适当的资源分配。在部署过程中，开发运维人员应该考虑使用 PodSecurityPolicy 和网络策略在整个集群中实施最低权限。

在下一章中，我们将从不同的角度来看待 Kubernetes 的安全性:了解不同类型资源的安全边界，以及如何加固它们。

# 问题

1.  什么是 Kubernetes 中的角色对象？
2.  Kubernetes 中的 RoleBinding 对象是什么？
3.  角色绑定和集群角色绑定对象有什么区别？
4.  默认情况下，pod 不能访问主机级命名空间。列举一些允许 pods 访问主机级命名空间的设置。
5.  如果您想限制 pod 对外部网络资源(例如，内部网络或互联网)的访问，您能做什么？

# 进一步阅读

大家可能已经注意到，我们在本章中谈到的一些安全控制机制已经存在很长时间了:SELinux **多类别安全/多级别安全** ( **MCS/MLS** )、AppArmor、seccomp、Linux 功能等等。已经有很多介绍这些技术的书籍或文章了。我鼓励您看一看以下材料，以便更好地理解如何使用它们来实现 Kubernetes 中的最低特权目标:

*   SELinux MCS:[https://access . red hat . com/documentation/en-us/red _ hat _ enterprise _ Linux/5/html/deployment _ guide/sec-MCS-getstarted](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/deployment_guide/sec-mcs-getstarted)
*   设备:[https://ubuntu.com/server/docs/security-apparmor](https://ubuntu.com/server/docs/security-apparmor)
*   Linux 功能:[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
*   帮助定义 RBAC 特权授予:[https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)